#!/usr/bin/env python3
"""ytmpctl - Command-line client for ytmpd sync daemon."""

import json
import os
import re
import socket
import subprocess
import sys
from pathlib import Path
from typing import Any, NoReturn


def get_sync_socket_path() -> Path:
    """Get the Unix socket path for ytmpd sync daemon.

    Returns:
        Path to the sync socket file.
    """
    config_dir = Path.home() / ".config" / "ytmpd"
    return config_dir / "sync_socket"


def send_command(command: str) -> dict[str, Any]:
    """Send a command to the ytmpd daemon and return the JSON response.

    Args:
        command: Command string to send to daemon

    Returns:
        Parsed JSON response as dict

    Raises:
        SystemExit: If connection fails or daemon returns error
    """
    socket_path = get_sync_socket_path()

    # Check if socket exists
    if not socket_path.exists():
        print("Error: ytmpd daemon is not running", file=sys.stderr)
        print("Start the daemon with: python -m ytmpd &", file=sys.stderr)
        sys.exit(1)

    try:
        # Connect to Unix socket
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(str(socket_path))

        # Send command
        sock.sendall((command + "\n").encode("utf-8"))

        # Receive response (read until newline)
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
            if b"\n" in response:
                break

        sock.close()

        # Parse JSON response
        response_text = response.decode("utf-8").strip()
        result = json.loads(response_text)

        return result

    except ConnectionRefusedError:
        print("Error: Failed to connect to daemon", file=sys.stderr)
        print("Make sure ytmpd is running: python -m ytmpd &", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print("Error: ytmpd daemon socket not found", file=sys.stderr)
        print("Start the daemon with: python -m ytmpd &", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid response from daemon: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def has_unicode_support() -> bool:
    """Check if terminal supports Unicode symbols.

    Returns:
        True if Unicode is supported, False otherwise.
    """
    # Check LANG environment variable for UTF-8
    lang = os.environ.get("LANG", "")
    return "UTF-8" in lang or "utf8" in lang


def has_color_support() -> bool:
    """Check if terminal supports ANSI color codes.

    Returns:
        True if colors are supported, False otherwise.
    """
    # Check if stdout is a TTY and TERM is set
    return sys.stdout.isatty() and os.environ.get("TERM", "dumb") != "dumb"


def colorize(text: str, color: str) -> str:
    """Colorize text if terminal supports it.

    Args:
        text: Text to colorize
        color: Color name (green, red, yellow, blue)

    Returns:
        Colored text or plain text if colors not supported
    """
    if not has_color_support():
        return text

    colors = {
        "green": "\033[32m",
        "red": "\033[31m",
        "yellow": "\033[33m",
        "blue": "\033[34m",
        "bold": "\033[1m",
        "reset": "\033[0m",
    }

    color_code = colors.get(color, "")
    reset_code = colors.get("reset", "")

    return f"{color_code}{text}{reset_code}"


def format_datetime(iso_str: str | None) -> str:
    """Format ISO datetime string to human-readable format.

    Args:
        iso_str: ISO format datetime string

    Returns:
        Formatted datetime or "Never" if None
    """
    if not iso_str:
        return "Never"

    # Simple formatting - just show date and time
    # Format: 2025-10-17T14:30:00Z -> 2025-10-17 14:30:00
    try:
        return iso_str.replace("T", " ").replace("Z", "")
    except Exception:
        return iso_str


def cmd_sync() -> None:
    """Trigger immediate sync."""
    print("Triggering sync...")
    result = send_command("sync")

    if result.get("success"):
        check = "✓" if has_unicode_support() else "OK"
        msg = result.get("message", "Sync triggered")
        print(colorize(f"{check} {msg}", "green"))
        print("Sync running in background. Use 'ytmpctl status' to check progress.")
    else:
        cross = "✗" if has_unicode_support() else "ERROR"
        error = result.get("error", "Unknown error")
        print(colorize(f"{cross} {error}", "red"), file=sys.stderr)
        sys.exit(1)


def cmd_status() -> None:
    """Show sync status and statistics."""
    result = send_command("status")

    if not result.get("success"):
        print(colorize("Error getting status", "red"), file=sys.stderr)
        sys.exit(1)

    # Header
    print(colorize("=== ytmpd Sync Status ===", "bold"))
    print()

    # Last sync time
    last_sync = format_datetime(result.get("last_sync"))
    print(f"Last sync: {last_sync}")

    # Daemon start time
    daemon_start = format_datetime(result.get("daemon_start_time"))
    print(f"Daemon started: {daemon_start}")
    print()

    # Sync in progress indicator
    if result.get("sync_in_progress"):
        print(colorize("Status: Sync in progress...", "yellow"))
    else:
        success = result.get("last_sync_success", False)
        if last_sync == "Never":
            print(colorize("Status: No sync performed yet", "yellow"))
        elif success:
            print(colorize("Status: Last sync successful", "green"))
        else:
            print(colorize("Status: Last sync had errors", "red"))
    print()

    # Statistics (only if we have sync results)
    if last_sync != "Never":
        print(colorize("=== Last Sync Statistics ===", "bold"))
        playlists_synced = result.get("playlists_synced", 0)
        playlists_failed = result.get("playlists_failed", 0)
        tracks_added = result.get("tracks_added", 0)
        tracks_failed = result.get("tracks_failed", 0)

        print(f"Playlists synced: {playlists_synced}")
        if playlists_failed > 0:
            print(colorize(f"Playlists failed: {playlists_failed}", "red"))

        print(f"Tracks added: {tracks_added}")
        if tracks_failed > 0:
            print(colorize(f"Tracks failed: {tracks_failed}", "yellow"))

        # Show errors if any
        errors = result.get("errors", [])
        if errors:
            print()
            print(colorize("=== Errors ===", "red"))
            for error in errors[:5]:  # Show max 5 errors
                print(f"  - {error}")
            if len(errors) > 5:
                print(f"  ... and {len(errors) - 5} more errors")


def cmd_list_playlists() -> None:
    """List YouTube Music playlists."""
    print("Fetching playlists from YouTube Music...")
    result = send_command("list")

    if not result.get("success"):
        error = result.get("error", "Unknown error")
        print(colorize(f"Error: {error}", "red"), file=sys.stderr)
        sys.exit(1)

    playlists = result.get("playlists", [])

    if not playlists:
        print("No playlists found.")
        return

    print()
    print(colorize("=== YouTube Music Playlists ===", "bold"))
    print()

    for playlist in playlists:
        name = playlist.get("name", "Unknown")
        track_count = playlist.get("track_count", 0)
        print(f"  • {name} ({track_count} tracks)")

    print()
    print(f"Total: {len(playlists)} playlists")
    print()
    print("To load a playlist in MPD, use:")
    print(colorize('  mpc load "YT: <playlist-name>"', "blue"))


def cmd_search() -> None:
    """Interactive search workflow for YouTube Music tracks."""
    try:
        # Step 1: Get search query
        print("Search YouTube Music:")
        query = input("> ").strip()

        if not query:
            print("Empty query. Exiting.")
            sys.exit(0)

        # Step 2: Send search command to daemon
        print(f"\nSearching for: {query}...")
        result = send_command(f"search {query}")

        if not result.get("success"):
            error = result.get("error", "Unknown error")
            print(colorize(f"✗ Search failed: {error}", "red"), file=sys.stderr)
            sys.exit(1)

        results = result.get("results", [])
        if not results:
            print("No results found.")
            sys.exit(0)

        # Step 3: Display results
        print()
        print(colorize(f'Search results for "{query}":', "bold"))
        print()
        for track in results:
            number = track["number"]
            title = track["title"]
            artist = track["artist"]
            duration = track["duration"]
            print(f"  {number}. {title} - {artist} ({duration})")

        # Step 4: Get track selection
        print()
        print(f"Enter number (1-{len(results)}), or 'q' to quit:")
        selection = input("> ").strip().lower()

        if selection == "q":
            print("Cancelled.")
            sys.exit(0)

        try:
            track_num = int(selection)
            if track_num < 1 or track_num > len(results):
                print(f"Invalid selection. Must be between 1 and {len(results)}.", file=sys.stderr)
                sys.exit(1)
        except ValueError:
            print("Invalid input. Must be a number or 'q'.", file=sys.stderr)
            sys.exit(1)

        selected_track = results[track_num - 1]

        # Step 5: Display action menu
        print()
        print(colorize(f"Selected: {selected_track['title']} - {selected_track['artist']}", "bold"))
        print()
        print("Actions:")
        print("  1. Play now")
        print("  2. Add to queue")
        print("  3. Start radio from this song")
        print("  4. Cancel")
        print()
        print("Enter choice (1-4):")
        action = input("> ").strip()

        if action == "4":
            print("Cancelled.")
            sys.exit(0)

        video_id = selected_track["video_id"]

        # Step 6: Execute action
        if action == "1":
            # Play now
            print("\nPlaying track...")
            resp = send_command(f"play {video_id}")
            if resp.get("success"):
                check = "✓" if has_unicode_support() else "OK"
                message = resp.get("message", "Playing...")
                print(colorize(f"{check} {message}", "green"))
            else:
                cross = "✗" if has_unicode_support() else "ERROR"
                error = resp.get("error", "Failed to play")
                print(colorize(f"{cross} Error: {error}", "red"), file=sys.stderr)
                sys.exit(1)

        elif action == "2":
            # Add to queue
            print("\nAdding to queue...")
            resp = send_command(f"queue {video_id}")
            if resp.get("success"):
                check = "✓" if has_unicode_support() else "OK"
                message = resp.get("message", "Added to queue.")
                print(colorize(f"{check} {message}", "green"))
            else:
                cross = "✗" if has_unicode_support() else "ERROR"
                error = resp.get("error", "Failed to add to queue")
                print(colorize(f"{cross} Error: {error}", "red"), file=sys.stderr)
                sys.exit(1)

        elif action == "3":
            # Start radio and apply
            print("\nGenerating radio playlist...")
            resp = send_command(f"radio {video_id}")
            if resp.get("success"):
                check = "✓" if has_unicode_support() else "OK"
                tracks = resp.get("tracks", 0)
                print(colorize(f"{check} Radio playlist created: {tracks} tracks", "green"))

                # Automatically apply the radio playlist
                print()
                print("Applying radio playlist to MPD...")

                # Load config to get MPD connection info
                import yaml

                config_path = Path.home() / ".config" / "ytmpd" / "config.yaml"
                mpd_socket = None
                mpd_port = 6600

                try:
                    if config_path.exists():
                        with open(config_path) as f:
                            config = yaml.safe_load(f)
                            # Check for mpd_socket_path (can be Unix socket or host:port)
                            socket_path = config.get("mpd_socket_path")
                            if socket_path:
                                if ":" in socket_path and not socket_path.startswith("/"):
                                    # It's a host:port format
                                    _, port_str = socket_path.split(":", 1)
                                    mpd_port = int(port_str)
                                else:
                                    # It's a Unix socket path
                                    mpd_socket = socket_path
                            # Fallback to separate host/port fields
                            elif "mpd_host" in config:
                                mpd_port = config.get("mpd_port", 6600)
                except Exception as e:
                    print(
                        colorize(f"Warning: Could not load config: {e}", "yellow"), file=sys.stderr
                    )

                # Build mpc command
                if mpd_socket:
                    # Unix socket connection
                    mpc_cmd = ["mpc", "-h", mpd_socket]
                else:
                    # TCP connection
                    mpc_cmd = ["mpc", "-p", str(mpd_port)]

                try:
                    # Clear current playlist
                    subprocess.run(mpc_cmd + ["clear"], check=True, capture_output=True)

                    # Load radio playlist from music directory
                    # XSPF playlists are in music dir, not playlist dir
                    subprocess.run(
                        mpc_cmd + ["load", "_youtube/YT: Radio.xspf"],
                        check=True,
                        capture_output=True,
                    )

                    # Start playback
                    subprocess.run(mpc_cmd + ["play"], check=True, capture_output=True)

                    print(colorize(f"{check} Radio playlist loaded and playing!", "green"))
                except subprocess.CalledProcessError as e:
                    print(
                        colorize(f"✗ Failed to apply radio playlist: {e}", "red"), file=sys.stderr
                    )
                    sys.exit(1)
            else:
                cross = "✗" if has_unicode_support() else "ERROR"
                error = resp.get("error", "Failed to generate radio")
                print(colorize(f"{cross} Error: {error}", "red"), file=sys.stderr)
                sys.exit(1)

        else:
            print("Invalid choice. Must be 1-4.", file=sys.stderr)
            sys.exit(1)

    except KeyboardInterrupt:
        print("\nCancelled.")
        sys.exit(0)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        sys.exit(1)


def cmd_radio(apply: bool = False) -> None:
    """Generate radio playlist from currently playing track.

    Args:
        apply: If True, automatically clear playlist, load radio, and play.
    """
    print("Generating radio playlist from current track...")
    result = send_command("radio")

    if result.get("success"):
        check = "✓" if has_unicode_support() else "OK"
        tracks = result.get("tracks", 0)
        playlist = result.get("playlist", "YT: Radio")
        msg = f"Radio playlist created: {tracks} tracks"
        print(colorize(f"{check} {msg}", "green"))

        if apply:
            print()
            print("Applying radio playlist to MPD...")

            # Load config to get MPD connection info
            import yaml

            config_path = Path.home() / ".config" / "ytmpd" / "config.yaml"
            mpd_socket = None
            mpd_port = 6600

            try:
                if config_path.exists():
                    with open(config_path) as f:
                        config = yaml.safe_load(f)
                        # Check for mpd_socket_path (can be Unix socket or host:port)
                        socket_path = config.get("mpd_socket_path")
                        if socket_path:
                            if ":" in socket_path and not socket_path.startswith("/"):
                                # It's a host:port format
                                _, port_str = socket_path.split(":", 1)
                                mpd_port = int(port_str)
                            else:
                                # It's a Unix socket path
                                mpd_socket = socket_path
                        # Fallback to separate host/port fields
                        elif "mpd_host" in config:
                            mpd_port = config.get("mpd_port", 6600)
            except Exception as e:
                print(colorize(f"Warning: Could not load config: {e}", "yellow"), file=sys.stderr)

            # Build mpc command
            if mpd_socket:
                # Unix socket connection
                mpc_cmd = ["mpc", "-h", mpd_socket]
            else:
                # TCP connection
                mpc_cmd = ["mpc", "-p", str(mpd_port)]

            try:
                # Clear current playlist
                subprocess.run(mpc_cmd + ["clear"], check=True, capture_output=True)

                # Load radio playlist from music directory
                # XSPF playlists are in music dir, not playlist dir
                subprocess.run(
                    mpc_cmd + ["load", "_youtube/YT: Radio.xspf"], check=True, capture_output=True
                )

                # Start playback
                subprocess.run(mpc_cmd + ["play"], check=True, capture_output=True)

                print(colorize(f"{check} Radio playlist loaded and playing!", "green"))
            except subprocess.CalledProcessError as e:
                print(colorize(f"✗ Failed to apply radio playlist: {e}", "red"), file=sys.stderr)
                sys.exit(1)
        else:
            print()
            print(f"Playlist '{playlist}' is ready in MPD.")
            print("To load and play:")
            print(colorize('  mpc load "_youtube/YT: Radio.xspf"', "blue"))
            print(colorize("  mpc play", "blue"))
            print()
            print("Or use:")
            print(colorize("  ytmpctl radio --apply", "blue"))
    else:
        cross = "✗" if has_unicode_support() else "ERROR"
        error = result.get("error", "Unknown error")
        print(colorize(f"{cross} {error}", "red"), file=sys.stderr)
        sys.exit(1)


def get_mpd_connection_info() -> tuple[str | None, int]:
    """Get MPD connection info from config.

    Returns:
        Tuple of (socket_path, port). socket_path is None if using TCP.
    """
    import yaml

    config_path = Path.home() / ".config" / "ytmpd" / "config.yaml"
    mpd_socket = None
    mpd_port = 6600

    try:
        if config_path.exists():
            with open(config_path) as f:
                config = yaml.safe_load(f)
                socket_path = config.get("mpd_socket_path")
                if socket_path:
                    if ":" in socket_path and not socket_path.startswith("/"):
                        # It's a host:port format
                        _, port_str = socket_path.split(":", 1)
                        mpd_port = int(port_str)
                    else:
                        # It's a Unix socket path
                        mpd_socket = socket_path
                elif "mpd_host" in config:
                    mpd_port = config.get("mpd_port", 6600)
    except Exception:
        pass  # Use defaults

    return mpd_socket, mpd_port


def get_current_track_from_mpd() -> tuple[str, str, str]:
    """Get currently playing track from MPD.

    Returns:
        Tuple of (video_id, title, artist).

    Raises:
        SystemExit: If no track is playing or track is not from YouTube Music.
    """
    mpd_socket, mpd_port = get_mpd_connection_info()

    # Build mpc command
    if mpd_socket:
        mpc_cmd = ["mpc", "-h", mpd_socket]
    else:
        mpc_cmd = ["mpc", "-p", str(mpd_port)]

    try:
        # Get current track file path
        result = subprocess.run(
            mpc_cmd + ["current", "-f", "%file%"], capture_output=True, text=True, check=True
        )
        file_path = result.stdout.strip()

        if not file_path:
            print("Error: No track currently playing", file=sys.stderr)
            sys.exit(1)

        # Extract video_id from proxy URL
        # Format: http://localhost:6602/proxy/{video_id}
        match = re.search(r"/proxy/([a-zA-Z0-9_-]+)", file_path)
        if not match:
            print("Error: Current track is not a YouTube Music track", file=sys.stderr)
            sys.exit(1)

        video_id = match.group(1)

        # Get artist and title
        result = subprocess.run(
            mpc_cmd + ["current", "-f", "%artist%"], capture_output=True, text=True, check=True
        )
        artist = result.stdout.strip() or "Unknown Artist"

        result = subprocess.run(
            mpc_cmd + ["current", "-f", "%title%"], capture_output=True, text=True, check=True
        )
        title = result.stdout.strip() or "Unknown Title"

        return video_id, title, artist

    except subprocess.CalledProcessError:
        print("Error: Failed to get current track from MPD", file=sys.stderr)
        print("Make sure MPD is running and a track is playing", file=sys.stderr)
        sys.exit(1)


def cmd_like() -> None:
    """Toggle like for current track."""
    try:
        # Import here to avoid startup delay
        from ytmpd.exceptions import YTMusicAPIError, YTMusicAuthError, YTMusicNotFoundError
        from ytmpd.rating import RatingAction, RatingManager, RatingState
        from ytmpd.ytmusic import YTMusicClient

        # Get current track from MPD
        video_id, title, artist = get_current_track_from_mpd()

        # Initialize clients
        ytmusic = YTMusicClient()
        rating_mgr = RatingManager()

        # Get current rating
        current_rating = ytmusic.get_track_rating(video_id)

        # Apply toggle logic
        transition = rating_mgr.apply_action(current_rating, RatingAction.LIKE)

        # Set new rating
        ytmusic.set_track_rating(video_id, transition.new_state)

        # Show user feedback
        check = "✓" if has_unicode_support() else "OK"
        if transition.new_state == RatingState.LIKED:
            print(colorize(f"{check} {transition.user_message}: {artist} - {title}", "green"))
        else:
            print(f"{transition.user_message}: {artist} - {title}")

        # Trigger immediate sync if Liked Songs playlist content changed
        if (
            transition.new_state == RatingState.LIKED
            or transition.current_state == RatingState.LIKED
        ):
            print("\nTriggering sync to update playlists...")
            result = send_command("sync")
            if result.get("success"):
                print(colorize("Sync started in background", "green"))

    except YTMusicNotFoundError:
        cross = "✗" if has_unicode_support() else "ERROR"
        print(colorize(f"{cross} Track not found in YouTube Music", "red"), file=sys.stderr)
        sys.exit(1)
    except YTMusicAuthError:
        cross = "✗" if has_unicode_support() else "ERROR"
        print(colorize(f"{cross} Not authenticated with YouTube Music", "red"), file=sys.stderr)
        print("Run: python -m ytmpd.ytmusic setup-browser", file=sys.stderr)
        sys.exit(1)
    except YTMusicAPIError as e:
        cross = "✗" if has_unicode_support() else "ERROR"
        print(colorize(f"{cross} API error: {e}", "red"), file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        cross = "✗" if has_unicode_support() else "ERROR"
        print(colorize(f"{cross} Unexpected error: {e}", "red"), file=sys.stderr)
        sys.exit(1)


def cmd_dislike() -> None:
    """Toggle dislike for current track."""
    try:
        # Import here to avoid startup delay
        from ytmpd.exceptions import YTMusicAPIError, YTMusicAuthError, YTMusicNotFoundError
        from ytmpd.rating import RatingAction, RatingManager, RatingState
        from ytmpd.ytmusic import YTMusicClient

        # Get current track from MPD
        video_id, title, artist = get_current_track_from_mpd()

        # Initialize clients
        ytmusic = YTMusicClient()
        rating_mgr = RatingManager()

        # Get current rating
        current_rating = ytmusic.get_track_rating(video_id)

        # Apply toggle logic
        transition = rating_mgr.apply_action(current_rating, RatingAction.DISLIKE)

        # Set new rating
        ytmusic.set_track_rating(video_id, transition.new_state)

        # Show user feedback
        cross = "✗" if has_unicode_support() else "X"
        if transition.new_state == RatingState.DISLIKED:
            print(colorize(f"{cross} {transition.user_message}: {artist} - {title}", "red"))
        else:
            print(f"{transition.user_message}: {artist} - {title}")

        # Trigger immediate sync if Liked Songs playlist content changed
        if (
            transition.new_state == RatingState.LIKED
            or transition.current_state == RatingState.LIKED
        ):
            print("\nTriggering sync to update playlists...")
            result = send_command("sync")
            if result.get("success"):
                print(colorize("Sync started in background", "green"))

    except YTMusicNotFoundError:
        cross = "✗" if has_unicode_support() else "ERROR"
        print(colorize(f"{cross} Track not found in YouTube Music", "red"), file=sys.stderr)
        sys.exit(1)
    except YTMusicAuthError:
        cross = "✗" if has_unicode_support() else "ERROR"
        print(colorize(f"{cross} Not authenticated with YouTube Music", "red"), file=sys.stderr)
        print("Run: python -m ytmpd.ytmusic setup-browser", file=sys.stderr)
        sys.exit(1)
    except YTMusicAPIError as e:
        cross = "✗" if has_unicode_support() else "ERROR"
        print(colorize(f"{cross} API error: {e}", "red"), file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        cross = "✗" if has_unicode_support() else "ERROR"
        print(colorize(f"{cross} Unexpected error: {e}", "red"), file=sys.stderr)
        sys.exit(1)


def show_help() -> None:
    """Display help message."""
    help_text = f"""{colorize("ytmpctl", "bold")} - YouTube Music to MPD sync control

{colorize("Usage:", "bold")}
  ytmpctl sync              Trigger immediate sync
  ytmpctl status            Show sync status and statistics
  ytmpctl list-playlists    List YouTube Music playlists
  ytmpctl radio [--apply]   Generate radio playlist from current track
                            --apply: Automatically load and play the radio
  ytmpctl search            Interactive search for YouTube Music tracks
  ytmpctl like              Toggle like for current track
  ytmpctl dislike           Toggle dislike for current track
  ytmpctl help              Show this help message

{colorize("Playback Control:", "bold")}
  Use mpc for playback control of synced playlists:
    mpc load "YT: Favorites"    Load YouTube playlist in MPD
    mpc play                     Start playback
    mpc pause                    Pause playback
    mpc next                     Next track
    mpc prev                     Previous track
    mpc status                   Show playback status
    mpc current                  Show current track

{colorize("Configuration:", "bold")}
  Config file: ~/.config/ytmpd/config.yaml
  Auth file:   ~/.config/ytmpd/browser.json (or oauth.json)
  State file:  ~/.config/ytmpd/sync_state.json

{colorize("Logs:", "bold")}
  Log file: ~/.config/ytmpd/ytmpd.log

{colorize("Examples:", "bold")}
  # Start daemon in background
  python -m ytmpd &

  # Trigger sync manually
  ytmpctl sync

  # Check sync status
  ytmpctl status

  # List available playlists
  ytmpctl list-playlists

  # Load and play a YouTube playlist
  mpc load "YT: Workout"
  mpc play

{colorize("Note:", "bold")}
  ytmpd syncs YouTube Music playlists to MPD with "YT: " prefix.
  Playback is controlled through MPD using mpc commands.
  The daemon automatically syncs playlists periodically (default: 30 minutes).
"""
    print(help_text)


def main() -> NoReturn:
    """Main entry point for ytmpctl client."""
    if len(sys.argv) < 2:
        show_help()
        sys.exit(0)

    command = sys.argv[1].lower()
    args = sys.argv[2:]

    # Dispatch commands
    if command == "sync":
        cmd_sync()
    elif command == "status":
        cmd_status()
    elif command == "list-playlists" or command == "list":
        cmd_list_playlists()
    elif command == "radio":
        # Check for --apply flag
        apply = "--apply" in args
        cmd_radio(apply=apply)
    elif command == "search":
        cmd_search()
    elif command == "like":
        cmd_like()
    elif command == "dislike":
        cmd_dislike()
    elif command == "help" or command == "--help" or command == "-h":
        show_help()
    else:
        print(f"Error: Unknown command: {command}", file=sys.stderr)
        print("Run 'ytmpctl help' for usage information", file=sys.stderr)
        sys.exit(1)

    sys.exit(0)


if __name__ == "__main__":
    main()
