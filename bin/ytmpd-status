#!/usr/bin/env python3
"""ytmpd-status - i3blocks status script for ytmpd.

This script queries MPD status and formats it for i3blocks display,
with special handling for YouTube-streamed vs local tracks.

Environment Variables:
    YTMPD_STATUS_MAX_LENGTH: Maximum length before truncation (default: 50)
    YTMPD_STATUS_FORMAT: Custom format string (default: "{icon} {artist} - {title} [{position}/{duration}]")

Color Codes (for i3blocks):
    YouTube Playing: #FF6B35 (orange)
    YouTube Paused: #FFB84D (light orange)
    Local Playing: #00FF00 (green)
    Local Paused: #FFFF00 (yellow)
    Stopped: #808080 (gray)
"""

import os
import sqlite3
import sys
from pathlib import Path

from mpd import MPDClient, ConnectionError as MPDConnectionError


def get_mpd_client(host: str = "localhost", port: int = 6601) -> MPDClient | None:
    """Connect to MPD server and return client.

    Args:
        host: MPD server hostname (default: localhost)
        port: MPD server port (default: 6601)

    Returns:
        MPDClient instance if connected, None if connection failed.
    """
    try:
        client = MPDClient()
        client.connect(host, port)
        return client
    except (MPDConnectionError, ConnectionRefusedError, OSError):
        return None


def get_track_type(file_path: str) -> str:
    """Determine if track is a YouTube stream or local file.

    Args:
        file_path: File path from MPD currentsong (file field).

    Returns:
        'youtube', 'local', or 'unknown'
    """
    # Check if it's a YouTube proxy stream
    if file_path.startswith("http://localhost:6602/proxy/"):
        return "youtube"

    # Check ytmpd database for additional YouTube tracks
    db_path = Path.home() / ".config" / "ytmpd" / "track_mapping.db"
    if not db_path.exists():
        # No database, assume local if not a proxy URL
        return "local" if not file_path.startswith("http") else "unknown"

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Query for this file path
        cursor.execute(
            "SELECT COUNT(*) FROM tracks WHERE file = ?",
            (file_path,)
        )
        count = cursor.fetchone()[0]
        conn.close()

        if count > 0:
            return "youtube"

        # Not in database - assume local
        return "local" if not file_path.startswith("http") else "unknown"

    except (sqlite3.Error, OSError):
        # Database error - fall back to heuristic
        return "local" if not file_path.startswith("http") else "unknown"


def format_time(seconds: int | str) -> str:
    """Format seconds as MM:SS.

    Args:
        seconds: Time in seconds as int or string.

    Returns:
        Formatted time string.
    """
    try:
        total_seconds = int(float(seconds))
        minutes = total_seconds // 60
        secs = total_seconds % 60
        return f"{minutes}:{secs:02d}"
    except (ValueError, TypeError):
        return "0:00"


def truncate(text: str, max_length: int) -> str:
    """Truncate text to max_length with ellipsis if needed.

    Args:
        text: Text to truncate.
        max_length: Maximum length.

    Returns:
        Truncated text.
    """
    if len(text) <= max_length:
        return text
    return text[: max_length - 3] + "..."


def main() -> None:
    """Display MPD/ytmpd status for i3blocks."""
    # Get configuration from environment
    max_length = int(os.environ.get("YTMPD_STATUS_MAX_LENGTH", "50"))

    # Connect to MPD
    client = get_mpd_client()

    if client is None:
        # MPD not running
        print("⏹ MPD stopped")
        print("⏹ MPD stopped")  # Short text
        print("#808080")  # Gray color
        sys.exit(0)

    try:
        # Get current status and song
        status = client.status()
        current_song = client.currentsong()

        state = status.get("state", "stop")

        if state == "stop" or not current_song:
            print("⏹ Stopped")
            print("⏹ Stopped")  # Short text
            print("#808080")  # Gray color
            client.close()
            sys.exit(0)

        # Get song info
        title = current_song.get("title", "Unknown")
        artist = current_song.get("artist", "Unknown")
        file_path = current_song.get("file", "")

        # Get timing info
        elapsed = status.get("elapsed", "0")
        duration = status.get("duration", current_song.get("time", "0"))

        # Format time
        position_str = format_time(elapsed)
        duration_str = format_time(duration)

        # Classify track type
        track_type = get_track_type(file_path)

        # Choose icon and color based on state and track type
        if state == "play":
            icon = "▶"
            if track_type == "youtube":
                color = "#FF6B35"  # Orange for YouTube
            else:
                color = "#00FF00"  # Green for local
        elif state == "pause":
            icon = "⏸"
            if track_type == "youtube":
                color = "#FFB84D"  # Light orange for YouTube paused
            else:
                color = "#FFFF00"  # Yellow for local paused
        else:
            icon = "⏹"
            color = "#808080"  # Gray for stopped

        # Build output string
        output = f"{icon} {artist} - {title} [{position_str}/{duration_str}]"

        # Truncate if needed
        output = truncate(output, max_length)

        # Output for i3blocks
        print(output)  # Full text
        print(output)  # Short text (same as full for now)
        print(color)  # Color

    except Exception as e:
        # Unexpected error
        print(f"⏹ Error: {e}")
        print("⏹ Error")
        print("#808080")
    finally:
        if client:
            client.close()


if __name__ == "__main__":
    main()
