#!/usr/bin/env python3
"""ytmpd-status - i3blocks status script for ytmpd.

This script queries MPD status and formats it for i3blocks display,
with special handling for YouTube-streamed vs local tracks.

Environment Variables (deprecated - use CLI args instead):
    YTMPD_STATUS_MAX_LENGTH: Maximum length before truncation (default: 50)
    YTMPD_STATUS_BAR_LENGTH: Progress bar length in characters (default: 10)
    YTMPD_STATUS_SHOW_BAR: Enable/disable progress bar (default: true)
    YTMPD_STATUS_BAR_STYLE: Force specific bar style - 'blocks', 'smooth', or 'simple'
                            (default: auto-detect based on track type)
    YTMPD_STATUS_SHOW_NEXT: Show next track info (default: false)
    YTMPD_STATUS_SHOW_PREV: Show previous track info (default: false)
    YTMPD_STATUS_COMPACT: Minimal output mode (default: false)

Progress Bar Styles:
    blocks: █████░░░░░ (used for local tracks)
    smooth: ▰▰▰▰▰▱▱▱▱▱ (used for YouTube tracks)
    simple: #####----- (ASCII fallback)

Color Codes (for i3blocks):
    YouTube Playing: #FF6B35 (orange)
    YouTube Paused: #FFB84D (light orange)
    Local Playing: #00FF00 (green)
    Local Paused: #FFFF00 (yellow)
    Stopped: #808080 (gray)
"""

# Auto-detect and use venv if available
import os
import sys
from pathlib import Path

_script_dir = Path(__file__).resolve().parent.parent
_venv_python = _script_dir / ".venv" / "bin" / "python"

if _venv_python.exists() and sys.executable != str(_venv_python):
    # Re-exec using venv Python
    os.execv(str(_venv_python), [str(_venv_python)] + sys.argv)

import argparse  # noqa: E402
import re  # noqa: E402
import signal  # noqa: E402
import sqlite3  # noqa: E402
import time  # noqa: E402

from mpd import ConnectionError as MPDConnectionError  # noqa: E402
from mpd import MPDClient  # noqa: E402

__version__ = "2.1.0"


def get_mpd_client(host: str = "localhost", port: int = 6601) -> MPDClient | None:
    """Connect to MPD server and return client.

    Args:
        host: MPD server hostname (default: localhost)
        port: MPD server port (default: 6601)

    Returns:
        MPDClient instance if connected, None if connection failed.
    """
    try:
        client = MPDClient()
        client.connect(host, port)
        return client
    except (MPDConnectionError, ConnectionRefusedError, OSError):
        return None


def get_track_type(file_path: str) -> str:
    """Determine if track is a YouTube stream or local file.

    Args:
        file_path: File path from MPD currentsong (file field).

    Returns:
        'youtube', 'local', or 'unknown'
    """
    # Check if it's a YouTube proxy stream
    if file_path.startswith("http://localhost:6602/proxy/"):
        return "youtube"

    # Check ytmpd database for additional YouTube tracks
    db_path = Path.home() / ".config" / "ytmpd" / "track_mapping.db"
    if not db_path.exists():
        # No database, assume local if not a proxy URL
        return "local" if not file_path.startswith("http") else "unknown"

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Query for this file path
        cursor.execute("SELECT COUNT(*) FROM tracks WHERE file = ?", (file_path,))
        count = cursor.fetchone()[0]
        conn.close()

        if count > 0:
            return "youtube"

        # Not in database - assume local
        return "local" if not file_path.startswith("http") else "unknown"

    except (sqlite3.Error, OSError):
        # Database error - fall back to heuristic
        return "local" if not file_path.startswith("http") else "unknown"


def format_time(seconds: int | str) -> str:
    """Format seconds as MM:SS.

    Args:
        seconds: Time in seconds as int or string.

    Returns:
        Formatted time string.
    """
    try:
        total_seconds = int(float(seconds))
        minutes = total_seconds // 60
        secs = total_seconds % 60
        return f"{minutes}:{secs:02d}"
    except (ValueError, TypeError):
        return "0:00"


def truncate(text: str, max_length: int) -> str:
    """Truncate text to max_length with ellipsis if needed.

    Args:
        text: Text to truncate.
        max_length: Maximum length.

    Returns:
        Truncated text.
    """
    if len(text) <= max_length:
        return text
    return text[: max_length - 3] + "..."


def calculate_progress(elapsed: float, duration: float, bar_length: int) -> int:
    """Calculate number of filled blocks in progress bar.

    Args:
        elapsed: Current playback position in seconds.
        duration: Total track duration in seconds.
        bar_length: Total length of progress bar in characters.

    Returns:
        Number of filled blocks (0 to bar_length).
    """
    # Handle edge cases
    if duration <= 0:
        return 0
    if elapsed <= 0:
        return 0
    if elapsed >= duration:
        return bar_length

    # Calculate filled portion
    progress_ratio = elapsed / duration
    filled_blocks = int(progress_ratio * bar_length)

    # Ensure within bounds
    return max(0, min(filled_blocks, bar_length))


def render_progress_bar(filled: int, total_length: int, style: str = "blocks") -> str:
    """Render progress bar with specified style.

    Args:
        filled: Number of filled blocks.
        total_length: Total bar length in characters.
        style: Bar style - 'blocks', 'smooth', or 'simple'.

    Returns:
        Rendered progress bar string.
    """
    # Define style characters
    styles = {
        "blocks": {"filled": "█", "empty": "░"},
        "smooth": {"filled": "▰", "empty": "▱"},
        "simple": {"filled": "#", "empty": "-"},
    }

    # Get characters for the specified style (default to blocks if unknown)
    chars = styles.get(style, styles["blocks"])
    filled_char = chars["filled"]
    empty_char = chars["empty"]

    # Ensure filled is within bounds
    filled = max(0, min(filled, total_length))
    empty = total_length - filled

    # Build the bar
    return filled_char * filled + empty_char * empty


def get_playlist_context(client: MPDClient) -> dict:
    """Get playlist context including current position and adjacent tracks.

    Args:
        client: Connected MPDClient instance.

    Returns:
        Dictionary with keys:
        - 'current_pos': Current track position (1-indexed) or None
        - 'total': Total tracks in playlist or None
        - 'next': Dict with 'artist' and 'title' for next track, or None
        - 'prev': Dict with 'artist' and 'title' for previous track, or None
    """
    try:
        status = client.status()

        # Get current position (0-indexed in MPD, convert to 1-indexed)
        song_pos = status.get("song")
        if song_pos is None:
            return {"current_pos": None, "total": None, "next": None, "prev": None}

        current_pos = int(song_pos) + 1  # Convert to 1-indexed

        # Get playlist length
        playlist_length = int(status.get("playlistlength", 0))

        # Initialize adjacent track info
        next_track = None
        prev_track = None

        # Get next track info if not the last song
        if current_pos < playlist_length:
            next_song_info = client.playlistinfo(str(int(song_pos) + 1))
            if next_song_info:
                next_track = {
                    "artist": next_song_info[0].get("artist", "Unknown"),
                    "title": next_song_info[0].get("title", "Unknown"),
                }

        # Get previous track info if not the first song
        if current_pos > 1:
            prev_song_info = client.playlistinfo(str(int(song_pos) - 1))
            if prev_song_info:
                prev_track = {
                    "artist": prev_song_info[0].get("artist", "Unknown"),
                    "title": prev_song_info[0].get("title", "Unknown"),
                }

        return {
            "current_pos": current_pos,
            "total": playlist_length,
            "next": next_track,
            "prev": prev_track,
        }

    except Exception:
        # If any error occurs, return empty context
        return {"current_pos": None, "total": None, "next": None, "prev": None}


def get_sync_status(file_path: str) -> str:
    """Check if a YouTube track's stream URL is resolved in the database.

    Args:
        file_path: File path from MPD currentsong (file field).

    Returns:
        Status string: 'resolved', 'unresolved', 'local', or 'unknown'
    """
    # Not a YouTube proxy URL - must be local
    if not file_path.startswith("http://localhost:6602/proxy/"):
        return "local"

    # Extract video ID from proxy URL
    video_id = file_path.replace("http://localhost:6602/proxy/", "")

    # Check database
    db_path = Path.home() / ".config" / "ytmpd" / "track_mapping.db"
    if not db_path.exists():
        return "unknown"

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Check if stream_url is NULL (unresolved)
        cursor.execute("SELECT stream_url FROM tracks WHERE video_id = ?", (video_id,))
        result = cursor.fetchone()
        conn.close()

        if result is None:
            # Video ID not in database
            return "unknown"

        stream_url = result[0]
        if stream_url is None:
            # Stream URL is NULL - unresolved
            return "unresolved"
        else:
            # Stream URL exists - resolved
            return "resolved"

    except (sqlite3.Error, OSError):
        return "unknown"


def smart_truncate(text: str, max_length: int) -> str:
    """Truncate text intelligently, preserving important parts.

    Attempts to truncate from the middle of long titles while preserving
    artist names and using proper ellipsis character.

    Args:
        text: Text to truncate.
        max_length: Maximum length.

    Returns:
        Truncated text with proper ellipsis (…) if needed.
    """
    if len(text) <= max_length:
        return text

    # Use proper ellipsis character
    ellipsis = "…"

    # Try to find " - " separator (between artist and title)
    separator_pos = text.find(" - ")

    if separator_pos == -1 or separator_pos > max_length - 10:
        # No separator or artist name is too long
        # Just truncate from the end
        return text[: max_length - 1] + ellipsis

    # We have an artist - title structure
    artist = text[:separator_pos]
    rest = text[separator_pos:]  # Includes " - " and title

    # If artist alone is too long, truncate it
    if len(artist) > max_length - 10:
        return artist[: max_length - 1] + ellipsis

    # Calculate space available for title part
    available_for_rest = max_length - len(artist) - 1  # -1 for ellipsis

    if len(rest) <= available_for_rest:
        return text  # Should not happen given outer check, but safety

    # Truncate the title part, preserving artist
    # Try to truncate from middle of title if possible
    title_part = rest[3:]  # Remove " - "
    if len(title_part) > 20:
        # Long title - truncate from middle
        keep_start = (available_for_rest - 4) // 2  # -4 for " - " and ellipsis
        keep_end = available_for_rest - 4 - keep_start
        truncated_title = title_part[:keep_start] + ellipsis + title_part[-keep_end:]
        return f"{artist} - {truncated_title}"
    else:
        # Short title - truncate from end
        max_title_len = available_for_rest - 3  # -3 for " - "
        truncated_title = title_part[: max_title_len - 1] + ellipsis
        return f"{artist} - {truncated_title}"


def adaptive_truncate_status(
    icon: str,
    artist: str,
    title: str,
    position_str: str,
    duration_str: str,
    progress_bar_str: str,
    context_suffix: str,
    max_length: int,
    min_bar_length: int = 5,
    fixed_bar_length: bool = False,
) -> str:
    """Adaptively truncate status line with protected elements.

    This function ensures that timestamps (position_str, duration_str) are NEVER
    truncated, the progress bar can shrink to a minimum size, and the song name
    (artist - title) is truncated as needed.

    Priority (from highest to lowest):
    1. Icon, brackets, timestamps - NEVER truncated
    2. Progress bar - can shrink to min_bar_length (or be hidden entirely)
       If fixed_bar_length is True, bar never shrinks (only hidden if no space)
    3. Song name - can be truncated with ellipsis

    Args:
        icon: Playback icon (▶, ⏸, ⏹).
        artist: Artist name.
        title: Song title.
        position_str: Current time (e.g., "1:23").
        duration_str: Total duration (e.g., "3:45").
        progress_bar_str: Progress bar string (may be empty if disabled).
        context_suffix: Additional context like "[Resolving...]" or position.
        max_length: Maximum total output length.
        min_bar_length: Minimum progress bar length before hiding it.
        fixed_bar_length: If True, never shrink the bar (only show at full length or hide).

    Returns:
        Formatted and truncated status string.
    """
    ellipsis = "…"

    # Calculate the length of protected elements (never truncate these)
    # Format: "{icon} {artist} - {title} [{position_str} {bar} {duration_str}]{suffix}"
    protected_base = (
        len(icon)
        + 1  # space after icon
        + 1  # space before bracket
        + 1  # opening bracket "["
        + len(position_str)
        + 1  # space after position
        + 1  # space before duration
        + len(duration_str)
        + 1  # closing bracket "]"
        + len(context_suffix)
    )

    # Calculate available space for song name and progress bar
    available_space = max_length - protected_base

    # Minimum viable song name (at least "A…")
    min_song_length = 2

    # If we can't even fit the bare minimum, just truncate everything
    if available_space < min_song_length:
        # Emergency fallback: just show what we can
        result = (
            f"{icon} {artist} - {title} "
            f"[{position_str} {progress_bar_str} {duration_str}]{context_suffix}"
        )
        return result[: max_length - 1] + ellipsis if len(result) > max_length else result

    # Try to fit: song name + full progress bar
    song_name = f"{artist} - {title}"
    full_output_length = len(song_name) + len(progress_bar_str)

    if full_output_length <= available_space:
        # Everything fits!
        bar_part = f" {progress_bar_str}" if progress_bar_str else ""
        return f"{icon} {song_name} [{position_str}{bar_part} {duration_str}]{context_suffix}"

    # Need to make adjustments
    current_bar_length = len(progress_bar_str)
    bar_to_use = progress_bar_str

    # Try shrinking the progress bar first (only if not fixed)
    if not fixed_bar_length and current_bar_length > min_bar_length:
        # Calculate how much we need to shrink
        needed_space = full_output_length - available_space
        new_bar_length = max(min_bar_length, current_bar_length - needed_space)

        # Rebuild progress bar with new length
        if progress_bar_str:
            # Determine the bar style by checking the characters
            if "█" in progress_bar_str or "░" in progress_bar_str:
                style = "blocks"
            elif "▰" in progress_bar_str or "▱" in progress_bar_str:
                style = "smooth"
            else:
                style = "simple"

            # Calculate filled ratio
            if "█" in progress_bar_str:
                filled = progress_bar_str.count("█")
            elif "▰" in progress_bar_str:
                filled = progress_bar_str.count("▰")
            elif "#" in progress_bar_str:
                filled = progress_bar_str.count("#")
            else:
                filled = 0

            filled_ratio = filled / current_bar_length if current_bar_length > 0 else 0
            new_filled = int(filled_ratio * new_bar_length)

            bar_to_use = render_progress_bar(new_filled, new_bar_length, style)

        # Recalculate with new bar
        full_output_length = len(song_name) + len(bar_to_use)

        if full_output_length <= available_space:
            bar_part = f" {bar_to_use}" if bar_to_use else ""
            return f"{icon} {song_name} [{position_str}{bar_part} {duration_str}]{context_suffix}"

    # Still doesn't fit - handle based on fixed_bar_length setting
    if full_output_length > available_space:
        if fixed_bar_length:
            # Fixed bar mode: ALWAYS show bar at full length, truncate song name to fit
            available_for_song = available_space - len(progress_bar_str)

            # Need to truncate the song name
            if len(song_name) > available_for_song:
                # Try to preserve artist name if possible
                separator_pos = song_name.find(" - ")

                if separator_pos != -1 and separator_pos < available_for_song - 5:
                    # Try to keep artist and truncate title
                    artist_part = song_name[:separator_pos]
                    title_part = song_name[separator_pos + 3 :]  # Skip " - "

                    # Calculate space for title
                    available_for_title = (
                        available_for_song - len(artist_part) - 3 - 1
                    )  # " - " + ellipsis

                    if available_for_title >= 2:
                        truncated_title = title_part[: available_for_title - 1] + ellipsis
                        truncated_song = f"{artist_part} - {truncated_title}"
                    else:
                        # Not enough room for title, truncate artist instead
                        truncated_song = song_name[: available_for_song - 1] + ellipsis
                else:
                    # Artist name too long or no separator - truncate from end
                    truncated_song = song_name[: available_for_song - 1] + ellipsis
            else:
                truncated_song = song_name

            # Always include the bar
            bar_part = f" {progress_bar_str}" if progress_bar_str else ""
            return (
                f"{icon} {truncated_song} [{position_str}{bar_part} {duration_str}]{context_suffix}"
            )
        else:
            # Non-fixed bar mode: hide the bar and use all space for song name
            available_for_song = available_space

            if len(song_name) <= available_for_song:
                # Fits without bar
                return f"{icon} {song_name} [{position_str} {duration_str}]{context_suffix}"

            # Need to truncate the song name
            # Try to preserve artist name if possible
            separator_pos = song_name.find(" - ")

            if separator_pos != -1 and separator_pos < available_for_song - 5:
                # Try to keep artist and truncate title
                artist_part = song_name[:separator_pos]
                title_part = song_name[separator_pos + 3 :]  # Skip " - "

                # Calculate space for title
                available_for_title = (
                    available_for_song - len(artist_part) - 3 - 1
                )  # " - " + ellipsis

                if available_for_title >= 2:
                    truncated_title = title_part[: available_for_title - 1] + ellipsis
                    truncated_song = f"{artist_part} - {truncated_title}"
                    return (
                        f"{icon} {truncated_song} [{position_str} {duration_str}]{context_suffix}"
                    )

            # Artist name too long or no separator - truncate from end
            truncated_song = song_name[: available_for_song - 1] + ellipsis
            return f"{icon} {truncated_song} [{position_str} {duration_str}]{context_suffix}"

    # Fallback (shouldn't reach here)
    bar_part = f" {bar_to_use}" if bar_to_use else ""
    result = f"{icon} {song_name} [{position_str}{bar_part} {duration_str}]{context_suffix}"
    return result[: max_length - 1] + ellipsis if len(result) > max_length else result


def validate_color(color: str) -> str:
    """Validate hex color format.

    Args:
        color: Color string to validate (e.g., "#FF6B35").

    Returns:
        Validated color string.

    Raises:
        argparse.ArgumentTypeError: If color format is invalid.
    """
    if not re.match(r"^#[0-9A-Fa-f]{6}$", color):
        raise argparse.ArgumentTypeError(f"Invalid color format: {color}. Expected format: #RRGGBB")
    return color


def validate_port(value: str) -> int:
    """Validate port number.

    Args:
        value: Port number as string.

    Returns:
        Validated port as int.

    Raises:
        argparse.ArgumentTypeError: If port is out of range.
    """
    try:
        port = int(value)
        if not 1 <= port <= 65535:
            raise ValueError
        return port
    except ValueError:
        raise argparse.ArgumentTypeError(f"Invalid port: {value}. Must be between 1 and 65535")


def validate_positive_int(value: str, min_val: int, max_val: int, name: str) -> int:
    """Validate positive integer within range.

    Args:
        value: Value as string.
        min_val: Minimum allowed value.
        max_val: Maximum allowed value.
        name: Name of parameter for error message.

    Returns:
        Validated integer.

    Raises:
        argparse.ArgumentTypeError: If value is out of range.
    """
    try:
        val = int(value)
        if not min_val <= val <= max_val:
            raise ValueError
        return val
    except ValueError:
        raise argparse.ArgumentTypeError(
            f"Invalid {name}: {value}. Must be between {min_val} and {max_val}"
        )


def parse_arguments() -> argparse.Namespace:
    """Parse command-line arguments with backward compatibility for env vars.

    Returns:
        Parsed arguments namespace.
    """
    parser = argparse.ArgumentParser(
        prog="ytmpd-status",
        description="Display ytmpd/MPD status for i3blocks with YouTube track detection",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Format String Placeholders:
  {icon}      - Playback status icon (▶, ⏸, ⏹)
  {artist}    - Track artist
  {title}     - Track title
  {album}     - Album name
  {elapsed}   - Elapsed time (formatted as M:SS)
  {duration}  - Total duration (formatted as M:SS)
  {bar}       - Progress bar
  {position}  - Current track position in playlist
  {total}     - Total tracks in playlist
  {next}      - Next track (if available)
  {prev}      - Previous track (if available)

Examples:
  ytmpd-status
  ytmpd-status --compact --no-show-bar
  ytmpd-status --format "{icon} {title} ({elapsed}/{duration})"
  ytmpd-status --bar-length 15 --show-next
  ytmpd-status --host localhost --port 6600
        """,
    )

    # Version
    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
    )

    # Connection options
    conn_group = parser.add_argument_group("Connection Options")
    conn_group.add_argument(
        "--host",
        default=os.environ.get("YTMPD_STATUS_HOST", "localhost"),
        help="MPD server host (default: localhost)",
    )
    conn_group.add_argument(
        "--port",
        type=validate_port,
        default=int(os.environ.get("YTMPD_STATUS_PORT", "6601")),
        help="MPD server port (default: 6601)",
    )

    # Display options
    display_group = parser.add_argument_group("Display Options")
    display_group.add_argument(
        "-l",
        "--max-length",
        type=lambda x: validate_positive_int(x, 1, 200, "max-length"),
        default=int(os.environ.get("YTMPD_STATUS_MAX_LENGTH", "50")),
        help="Maximum output length (default: 50)",
    )
    display_group.add_argument(
        "-f",
        "--format",
        default=os.environ.get("YTMPD_STATUS_FORMAT", ""),
        help="Custom format string (default: auto)",
    )
    display_group.add_argument(
        "-c",
        "--compact",
        action="store_true",
        default=os.environ.get("YTMPD_STATUS_COMPACT", "false").lower() in ("true", "1", "yes"),
        help="Use compact display mode",
    )

    # Progress bar options
    bar_group = parser.add_argument_group("Progress Bar Options")
    bar_group.add_argument(
        "--show-bar",
        action="store_true",
        dest="show_bar",
        default=None,
        help="Enable progress bar (default)",
    )
    bar_group.add_argument(
        "--no-show-bar",
        action="store_false",
        dest="show_bar",
        help="Disable progress bar",
    )
    bar_group.add_argument(
        "--bar-length",
        type=lambda x: validate_positive_int(x, 1, 50, "bar-length"),
        default=int(os.environ.get("YTMPD_STATUS_BAR_LENGTH", "10")),
        help="Progress bar length in characters (default: 10)",
    )
    bar_group.add_argument(
        "--bar-style",
        choices=["blocks", "smooth", "simple", "auto"],
        default=os.environ.get("YTMPD_STATUS_BAR_STYLE", "auto"),
        help="Progress bar style (default: auto)",
    )
    bar_group.add_argument(
        "--fixed-bar-length",
        action="store_true",
        default=os.environ.get("YTMPD_STATUS_FIXED_BAR_LENGTH", "false").lower()
        in ("true", "1", "yes"),
        help=(
            "Prevent progress bar from shrinking "
            "(always show at full --bar-length or hide entirely)"
        ),
    )

    # Playlist context options
    playlist_group = parser.add_argument_group("Playlist Context Options")
    playlist_group.add_argument(
        "--show-next",
        action="store_true",
        default=os.environ.get("YTMPD_STATUS_SHOW_NEXT", "false").lower() in ("true", "1", "yes"),
        help="Show next track",
    )
    playlist_group.add_argument(
        "--show-prev",
        action="store_true",
        default=os.environ.get("YTMPD_STATUS_SHOW_PREV", "false").lower() in ("true", "1", "yes"),
        help="Show previous track",
    )
    playlist_group.add_argument(
        "--show-position",
        action="store_true",
        default=os.environ.get("YTMPD_STATUS_SHOW_POSITION", "false").lower()
        in ("true", "1", "yes"),
        help="Show playlist position",
    )

    # Color options
    color_group = parser.add_argument_group("Color Options")
    color_group.add_argument(
        "--color-youtube-playing",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_YOUTUBE_PLAYING", "#FF6B35"),
        help="Color for YouTube playing (default: #FF6B35)",
    )
    color_group.add_argument(
        "--color-youtube-paused",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_YOUTUBE_PAUSED", "#FFB84D"),
        help="Color for YouTube paused (default: #FFB84D)",
    )
    color_group.add_argument(
        "--color-local-playing",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_LOCAL_PLAYING", "#00FF00"),
        help="Color for local playing (default: #00FF00)",
    )
    color_group.add_argument(
        "--color-local-paused",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_LOCAL_PAUSED", "#FFFF00"),
        help="Color for local paused (default: #FFFF00)",
    )
    color_group.add_argument(
        "--color-stopped",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_STOPPED", "#808080"),
        help="Color for stopped (default: #808080)",
    )

    # Icon options
    icon_group = parser.add_argument_group("Icon Options")
    icon_group.add_argument(
        "--icon-playing",
        default=os.environ.get("YTMPD_STATUS_ICON_PLAYING", "▶"),
        help="Icon for playing state (default: ▶)",
    )
    icon_group.add_argument(
        "--icon-paused",
        default=os.environ.get("YTMPD_STATUS_ICON_PAUSED", "⏸"),
        help="Icon for paused state (default: ⏸)",
    )
    icon_group.add_argument(
        "--icon-stopped",
        default=os.environ.get("YTMPD_STATUS_ICON_STOPPED", "⏹"),
        help="Icon for stopped state (default: ⏹)",
    )

    # Debug options
    debug_group = parser.add_argument_group("Debug Options")
    debug_group.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Verbose output (show connection info, etc.)",
    )

    # i3blocks integration options
    i3blocks_group = parser.add_argument_group("i3blocks Integration Options")
    i3blocks_group.add_argument(
        "--idle",
        action="store_true",
        help="Run in idle mode (monitor MPD for changes, minimal CPU usage)",
    )
    i3blocks_group.add_argument(
        "--handle-clicks",
        action="store_true",
        help="Handle i3blocks click events (via BLOCK_BUTTON env var)",
    )

    args = parser.parse_args()

    # Handle show_bar default (backward compatibility)
    if args.show_bar is None:
        # Not specified on CLI, check env var
        args.show_bar = os.environ.get("YTMPD_STATUS_SHOW_BAR", "true").lower() in (
            "true",
            "1",
            "yes",
        )

    # Convert bar_style "auto" to empty string for consistency with old code
    if args.bar_style == "auto":
        args.bar_style = ""

    return args


def format_with_template(template: str, data: dict) -> str:
    """Format output using template string with placeholders.

    Args:
        template: Format string with {placeholder} syntax.
        data: Dictionary with placeholder values.

    Returns:
        Formatted string.
    """
    # Replace placeholders with values
    output = template
    for key, value in data.items():
        placeholder = f"{{{key}}}"
        if placeholder in output:
            output = output.replace(placeholder, str(value) if value is not None else "")

    return output


# Global flag for signal handling
should_refresh = False
should_exit = False


def signal_handler_refresh(signum, frame):
    """Handle SIGUSR1 signal to trigger immediate refresh."""
    global should_refresh
    should_refresh = True


def signal_handler_exit(signum, frame):
    """Handle SIGTERM/SIGINT signals for graceful shutdown."""
    global should_exit
    should_exit = True


def handle_click(client: MPDClient, verbose: bool = False) -> bool:
    """Handle i3blocks click events via BLOCK_BUTTON environment variable.

    Args:
        client: Connected MPD client.
        verbose: Print debug information.

    Returns:
        True if a click was handled, False otherwise.
    """
    button = os.environ.get("BLOCK_BUTTON", "")

    if not button:
        return False

    if verbose:
        print(f"Handling click: button {button}", file=sys.stderr)

    try:
        if button == "1":  # Left click: toggle play/pause
            status = client.status()
            state = status.get("state", "stop")
            if state == "play":
                client.pause(1)
            elif state == "pause":
                client.pause(0)
            elif state == "stop":
                client.play()
            return True
        elif button == "2":  # Middle click: stop
            client.stop()
            return True
        elif button == "3":  # Right click: could show more info (reserved)
            return False
        elif button == "4":  # Scroll up: next track
            client.next()
            return True
        elif button == "5":  # Scroll down: previous track
            client.previous()
            return True
        else:
            return False

    except Exception as e:
        if verbose:
            print(f"Error handling click: {e}", file=sys.stderr)
        return False


def display_status(client: MPDClient, args, persist_mode: bool = False) -> None:
    """Display current MPD status once.

    Args:
        client: Connected MPD client.
        args: Parsed command-line arguments.
        persist_mode: If True, output single line for i3blocks persist mode.
    """
    try:
        # Get current status and song
        status = client.status()
        current_song = client.currentsong()

        state = status.get("state", "stop")

        if state == "stop" or not current_song:
            stop_icon = args.icon_stopped
            stop_msg = f"{stop_icon} Stopped"
            if persist_mode:
                print(stop_msg)
                sys.stdout.flush()
            else:
                print(stop_msg)
                print(stop_msg)  # Short text
                print(args.color_stopped)
                sys.stdout.flush()
            return

        # Get song info
        title = current_song.get("title", "Unknown")
        artist = current_song.get("artist", "Unknown")
        file_path = current_song.get("file", "")

        # Get timing info
        elapsed = status.get("elapsed", "0")
        duration = status.get("duration", current_song.get("time", "0"))

        # Format time
        position_str = format_time(elapsed)
        duration_str = format_time(duration)

        # Classify track type
        track_type = get_track_type(file_path)

        # Choose icon and color based on state and track type
        if state == "play":
            icon = args.icon_playing
            if track_type == "youtube":
                color = args.color_youtube_playing
            else:
                color = args.color_local_playing
        elif state == "pause":
            icon = args.icon_paused
            if track_type == "youtube":
                color = args.color_youtube_paused
            else:
                color = args.color_local_paused
        else:
            icon = args.icon_stopped
            color = args.color_stopped

        # Get playlist context
        playlist_ctx = get_playlist_context(client)

        # Check sync status for YouTube tracks
        sync_status = get_sync_status(file_path)

        # Build output (same logic as main())
        max_length = args.max_length
        bar_length = args.bar_length
        show_bar = args.show_bar
        bar_style = args.bar_style
        show_next = args.show_next
        show_prev = args.show_prev
        compact_mode = args.compact
        custom_format = args.format

        # Check if using custom format string
        if custom_format:
            # Build progress bar if needed in format
            progress_bar_str = ""
            if "{bar}" in custom_format and show_bar:
                try:
                    elapsed_float = float(elapsed)
                    duration_float = float(duration)
                    if duration_float > 0:
                        filled_blocks = calculate_progress(
                            elapsed_float, duration_float, bar_length
                        )
                        progress_bar_str = render_progress_bar(filled_blocks, bar_length, bar_style)
                except (ValueError, TypeError):
                    pass

            # Build template data
            template_data = {
                "icon": icon,
                "artist": artist,
                "title": title,
                "album": current_song.get("album", ""),
                "elapsed": position_str,
                "duration": duration_str,
                "bar": progress_bar_str,
                "position": playlist_ctx.get("position", ""),
                "total": playlist_ctx.get("total", ""),
                "next": (
                    f"{playlist_ctx['next']['artist']} - {playlist_ctx['next']['title']}"
                    if playlist_ctx.get("next")
                    else ""
                ),
                "prev": (
                    f"{playlist_ctx['prev']['artist']} - {playlist_ctx['prev']['title']}"
                    if playlist_ctx.get("prev")
                    else ""
                ),
            }

            # Format with template
            output = format_with_template(custom_format, template_data)
        else:
            # Default format logic
            if compact_mode:
                output = f"{icon} {artist} - {title}"
            else:
                # Build progress bar if enabled
                progress_bar_str = ""
                if show_bar:
                    try:
                        elapsed_float = float(elapsed)
                        duration_float = float(duration)
                        if duration_float > 0:
                            # Auto-detect bar style based on track type if not specified
                            if bar_style:
                                style = bar_style
                            else:
                                style = "smooth" if track_type == "youtube" else "blocks"
                            filled_blocks = calculate_progress(
                                elapsed_float, duration_float, bar_length
                            )
                            progress_bar_str = render_progress_bar(filled_blocks, bar_length, style)
                    except (ValueError, TypeError):
                        pass

                # Build context-aware suffix
                context_suffix = ""
                if sync_status == "unresolved":
                    # YouTube track not yet resolved
                    context_suffix = " [Resolving...]"
                elif playlist_ctx.get("current_pos") and playlist_ctx.get("total"):
                    pos = playlist_ctx["current_pos"]
                    total = playlist_ctx["total"]
                    # Show position for first, last, or single-track playlists
                    if total == 1:
                        context_suffix = " [1/1]"
                    elif pos == 1:
                        context_suffix = f" [1/{total}]"
                    elif pos == total:
                        context_suffix = f" [{total}/{total}]"

                # Use adaptive truncation that protects timestamps
                output = adaptive_truncate_status(
                    icon=icon,
                    artist=artist,
                    title=title,
                    position_str=position_str,
                    duration_str=duration_str,
                    progress_bar_str=progress_bar_str,
                    context_suffix=context_suffix,
                    max_length=max_length,
                    min_bar_length=5,
                    fixed_bar_length=args.fixed_bar_length,
                )

        # Truncate if needed (for compact mode or custom format)
        if compact_mode or custom_format:
            output = smart_truncate(output, max_length)

        # Build additional lines for next/previous tracks if enabled
        additional_lines = []

        if show_prev and playlist_ctx["prev"] is not None:
            prev = playlist_ctx["prev"]
            prev_line = f"↑ {prev['artist']} - {prev['title']}"
            prev_line = smart_truncate(prev_line, max_length)
            additional_lines.append(prev_line)

        if show_next and playlist_ctx["next"] is not None:
            next_track = playlist_ctx["next"]
            next_line = f"↓ {next_track['artist']} - {next_track['title']}"
            next_line = smart_truncate(next_line, max_length)
            additional_lines.append(next_line)

        # Output for i3blocks
        # If we have additional lines, append them to the full text
        if additional_lines:
            full_output = output + "\n" + "\n".join(additional_lines)
        else:
            full_output = output

        if persist_mode:
            # Persist mode: only output one line
            print(output)
            sys.stdout.flush()
        else:
            # Interval mode: output full_text, short_text, color
            print(full_output)  # Full text (may include next/prev)
            print(output)  # Short text (just main line)
            print(color)  # Color
            sys.stdout.flush()

    except Exception as e:
        # Unexpected error
        stop_icon = args.icon_stopped
        if persist_mode:
            print(f"{stop_icon} Error")
            sys.stdout.flush()
        else:
            print(f"{stop_icon} Error: {e}")
            print(f"{stop_icon} Error")
            print(args.color_stopped)
            sys.stdout.flush()


def run_idle_mode(args) -> None:
    """Run in idle mode, monitoring MPD for changes.

    Args:
        args: Parsed command-line arguments.
    """
    global should_refresh, should_exit

    # Set up signal handlers
    signal.signal(signal.SIGUSR1, signal_handler_refresh)
    signal.signal(signal.SIGTERM, signal_handler_exit)
    signal.signal(signal.SIGINT, signal_handler_exit)

    if args.verbose:
        print("Starting idle mode...", file=sys.stderr)

    client = None
    reconnect_delay = 1  # Start with 1 second delay

    while not should_exit:
        try:
            # Connect if not connected
            if client is None:
                if args.verbose:
                    print(
                        f"Connecting to MPD at {args.host}:{args.port}...",
                        file=sys.stderr,
                    )
                client = get_mpd_client(host=args.host, port=args.port)

                if client is None:
                    if args.verbose:
                        print(
                            f"MPD not available, retrying in {reconnect_delay}s...",
                            file=sys.stderr,
                        )
                    time.sleep(reconnect_delay)
                    reconnect_delay = min(reconnect_delay * 2, 30)  # Exponential backoff, max 30s
                    continue

                # Reset reconnect delay on successful connection
                reconnect_delay = 1

            # Check for click events
            if args.handle_clicks:
                block_button = os.environ.get("BLOCK_BUTTON", "")
                if block_button:
                    if handle_click(client, args.verbose):
                        # Click handled, display updated status
                        display_status(client, args, persist_mode=True)
                        # Clear BLOCK_BUTTON to prevent re-handling
                        os.environ.pop("BLOCK_BUTTON", None)
                    continue

            # Check if manual refresh requested
            if should_refresh:
                should_refresh = False
                if args.verbose:
                    print("Manual refresh triggered", file=sys.stderr)
                display_status(client, args, persist_mode=True)
                continue

            # Display current status
            display_status(client, args, persist_mode=True)

            # Sleep for 1 second to update progress bar during playback
            # This is simpler than trying to use MPD's idle with timeout
            time.sleep(1)

        except (
            MPDConnectionError,
            ConnectionRefusedError,
            OSError,
            BrokenPipeError,
        ) as e:
            # Connection lost
            if args.verbose:
                print(f"MPD connection error: {e}", file=sys.stderr)

            if client:
                try:
                    client.close()
                except Exception:
                    pass
                client = None

            # Wait before reconnecting
            if not should_exit:
                time.sleep(reconnect_delay)
                reconnect_delay = min(reconnect_delay * 2, 30)

        except Exception as e:
            # Unexpected error
            if args.verbose:
                print(f"Unexpected error: {e}", file=sys.stderr)

            # Try to recover
            if client:
                try:
                    client.close()
                except Exception:
                    pass
                client = None

            if not should_exit:
                time.sleep(1)

    # Cleanup on exit
    if client:
        try:
            client.close()
        except Exception:
            pass

    if args.verbose:
        print("Exiting idle mode", file=sys.stderr)


def main() -> None:
    """Display MPD/ytmpd status for i3blocks."""
    # Parse arguments (with backward compatibility for env vars)
    args = parse_arguments()

    # If idle mode requested, run that instead
    if args.idle:
        run_idle_mode(args)
        return

    # Extract configuration from args
    max_length = args.max_length
    bar_length = args.bar_length
    show_bar = args.show_bar
    bar_style = args.bar_style
    show_next = args.show_next
    show_prev = args.show_prev
    compact_mode = args.compact
    custom_format = args.format

    if args.verbose:
        print(f"Connecting to MPD at {args.host}:{args.port}", file=sys.stderr)

    # Connect to MPD
    client = get_mpd_client(host=args.host, port=args.port)

    if client is None:
        # MPD not running
        stop_icon = args.icon_stopped
        stop_color = args.color_stopped
        print(f"{stop_icon} MPD stopped")
        print(f"{stop_icon} MPD stopped")  # Short text
        print(stop_color)
        sys.exit(0)

    # Handle click events if requested (in polling mode)
    if args.handle_clicks:
        if handle_click(client, args.verbose):
            # Click handled, continue to display updated status
            pass

    try:
        # Get current status and song
        status = client.status()
        current_song = client.currentsong()

        state = status.get("state", "stop")

        if state == "stop" or not current_song:
            stop_icon = args.icon_stopped
            stop_color = args.color_stopped
            print(f"{stop_icon} Stopped")
            print(f"{stop_icon} Stopped")  # Short text
            print(stop_color)
            sys.stdout.flush()
            client.close()
            sys.exit(0)

        # Get song info
        title = current_song.get("title", "Unknown")
        artist = current_song.get("artist", "Unknown")
        file_path = current_song.get("file", "")

        # Get timing info
        elapsed = status.get("elapsed", "0")
        duration = status.get("duration", current_song.get("time", "0"))

        # Format time
        position_str = format_time(elapsed)
        duration_str = format_time(duration)

        # Classify track type
        track_type = get_track_type(file_path)

        # Choose icon and color based on state and track type
        if state == "play":
            icon = args.icon_playing
            if track_type == "youtube":
                color = args.color_youtube_playing
            else:
                color = args.color_local_playing
        elif state == "pause":
            icon = args.icon_paused
            if track_type == "youtube":
                color = args.color_youtube_paused
            else:
                color = args.color_local_paused
        else:
            icon = args.icon_stopped
            color = args.color_stopped

        # Get playlist context
        playlist_ctx = get_playlist_context(client)

        # Check sync status for YouTube tracks
        sync_status = get_sync_status(file_path)

        # Check if using custom format string
        if custom_format:
            # Build progress bar if needed in format
            progress_bar_str = ""
            if "{bar}" in custom_format and show_bar:
                try:
                    elapsed_float = float(elapsed)
                    duration_float = float(duration)
                    if duration_float > 0:
                        style = (
                            bar_style
                            if bar_style
                            else ("smooth" if track_type == "youtube" else "blocks")
                        )
                        filled_blocks = calculate_progress(
                            elapsed_float, duration_float, bar_length
                        )
                        progress_bar_str = render_progress_bar(filled_blocks, bar_length, style)
                except (ValueError, TypeError):
                    pass

            # Prepare data for template
            template_data = {
                "icon": icon,
                "artist": artist,
                "title": title,
                "album": current_song.get("album", ""),
                "elapsed": position_str,
                "duration": duration_str,
                "bar": progress_bar_str,
                "position": (playlist_ctx["current_pos"] if playlist_ctx["current_pos"] else ""),
                "total": playlist_ctx["total"] if playlist_ctx["total"] else "",
                "next": (
                    f"{playlist_ctx['next']['artist']} - {playlist_ctx['next']['title']}"
                    if playlist_ctx["next"]
                    else ""
                ),
                "prev": (
                    f"{playlist_ctx['prev']['artist']} - {playlist_ctx['prev']['title']}"
                    if playlist_ctx["prev"]
                    else ""
                ),
            }

            # Format using template
            output = format_with_template(custom_format, template_data)

        # Build output based on mode
        elif compact_mode:
            # Compact mode: just icon, artist, and title
            output = f"{icon} {artist} - {title}"
        else:
            # Build progress bar if enabled
            progress_bar_str = ""
            if show_bar:
                # Convert elapsed and duration to float for calculation
                try:
                    elapsed_float = float(elapsed)
                    duration_float = float(duration)

                    # Only show bar if we have a valid duration
                    if duration_float > 0:
                        # Determine bar style (auto-detect based on track type if not specified)
                        if bar_style:
                            style = bar_style
                        else:
                            style = "smooth" if track_type == "youtube" else "blocks"

                        # Calculate and render progress bar
                        filled_blocks = calculate_progress(
                            elapsed_float, duration_float, bar_length
                        )
                        progress_bar_str = render_progress_bar(filled_blocks, bar_length, style)
                except (ValueError, TypeError):
                    # If timing info is invalid, don't show bar
                    pass

            # Build context-aware suffix
            context_suffix = ""
            if sync_status == "unresolved":
                # YouTube track not yet resolved
                context_suffix = " [Resolving...]"
            elif playlist_ctx["current_pos"] is not None and playlist_ctx["total"] is not None:
                pos = playlist_ctx["current_pos"]
                total = playlist_ctx["total"]
                # Show position for first, last, or single track
                if total == 1:
                    context_suffix = " [1/1]"
                elif pos == 1:
                    context_suffix = f" [1/{total}]"
                elif pos == total:
                    context_suffix = f" [{total}/{total}]"

            # Use adaptive truncation that protects timestamps
            output = adaptive_truncate_status(
                icon=icon,
                artist=artist,
                title=title,
                position_str=position_str,
                duration_str=duration_str,
                progress_bar_str=progress_bar_str,
                context_suffix=context_suffix,
                max_length=max_length,
                min_bar_length=5,
                fixed_bar_length=args.fixed_bar_length,
            )

        # Truncate if needed (for compact mode or custom format)
        if compact_mode or custom_format:
            output = smart_truncate(output, max_length)

        # Build additional lines for next/previous tracks if enabled
        additional_lines = []

        if show_prev and playlist_ctx["prev"] is not None:
            prev = playlist_ctx["prev"]
            prev_line = f"↑ {prev['artist']} - {prev['title']}"
            prev_line = smart_truncate(prev_line, max_length)
            additional_lines.append(prev_line)

        if show_next and playlist_ctx["next"] is not None:
            next_track = playlist_ctx["next"]
            next_line = f"↓ {next_track['artist']} - {next_track['title']}"
            next_line = smart_truncate(next_line, max_length)
            additional_lines.append(next_line)

        # Output for i3blocks (interval mode - always 3-line format)
        # If we have additional lines, append them to the full text
        if additional_lines:
            full_output = output + "\n" + "\n".join(additional_lines)
        else:
            full_output = output

        # Interval mode: output full_text, short_text, color
        print(full_output)  # Full text (may include next/prev)
        print(output)  # Short text (just main line)
        print(color)  # Color
        sys.stdout.flush()

    except Exception as e:
        # Unexpected error (interval mode)
        stop_icon = args.icon_stopped
        print(f"{stop_icon} Error: {e}")
        print(f"{stop_icon} Error")
        print(args.color_stopped)
        sys.stdout.flush()
    finally:
        if client:
            client.close()


if __name__ == "__main__":
    main()
