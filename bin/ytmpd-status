#!/usr/bin/env python3
"""ytmpd-status - i3blocks status script for ytmpd.

This script queries MPD status and formats it for i3blocks display,
with special handling for YouTube-streamed vs local tracks.

Environment Variables (deprecated - use CLI args instead):
    YTMPD_STATUS_MAX_LENGTH: Maximum length before truncation (default: 50)
    YTMPD_STATUS_BAR_LENGTH: Progress bar length in characters (default: 10)
    YTMPD_STATUS_SHOW_BAR: Enable/disable progress bar (default: true)
    YTMPD_STATUS_BAR_STYLE: Force specific bar style - 'blocks', 'smooth', or 'simple'
                            (default: auto-detect based on track type)
    YTMPD_STATUS_SHOW_NEXT: Show next track info (default: false)
    YTMPD_STATUS_SHOW_PREV: Show previous track info (default: false)
    YTMPD_STATUS_COMPACT: Minimal output mode (default: false)

Progress Bar Styles:
    blocks: █████░░░░░ (used for local tracks)
    smooth: ▰▰▰▰▰▱▱▱▱▱ (used for YouTube tracks)
    simple: #####----- (ASCII fallback)

Color Codes (for i3blocks):
    YouTube Playing: #FF6B35 (orange)
    YouTube Paused: #FFB84D (light orange)
    Local Playing: #00FF00 (green)
    Local Paused: #FFFF00 (yellow)
    Stopped: #808080 (gray)
"""

import argparse
import os
import re
import sqlite3
import sys
from pathlib import Path

from mpd import MPDClient, ConnectionError as MPDConnectionError

__version__ = "2.0.0"


def get_mpd_client(host: str = "localhost", port: int = 6601) -> MPDClient | None:
    """Connect to MPD server and return client.

    Args:
        host: MPD server hostname (default: localhost)
        port: MPD server port (default: 6601)

    Returns:
        MPDClient instance if connected, None if connection failed.
    """
    try:
        client = MPDClient()
        client.connect(host, port)
        return client
    except (MPDConnectionError, ConnectionRefusedError, OSError):
        return None


def get_track_type(file_path: str) -> str:
    """Determine if track is a YouTube stream or local file.

    Args:
        file_path: File path from MPD currentsong (file field).

    Returns:
        'youtube', 'local', or 'unknown'
    """
    # Check if it's a YouTube proxy stream
    if file_path.startswith("http://localhost:6602/proxy/"):
        return "youtube"

    # Check ytmpd database for additional YouTube tracks
    db_path = Path.home() / ".config" / "ytmpd" / "track_mapping.db"
    if not db_path.exists():
        # No database, assume local if not a proxy URL
        return "local" if not file_path.startswith("http") else "unknown"

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Query for this file path
        cursor.execute(
            "SELECT COUNT(*) FROM tracks WHERE file = ?",
            (file_path,)
        )
        count = cursor.fetchone()[0]
        conn.close()

        if count > 0:
            return "youtube"

        # Not in database - assume local
        return "local" if not file_path.startswith("http") else "unknown"

    except (sqlite3.Error, OSError):
        # Database error - fall back to heuristic
        return "local" if not file_path.startswith("http") else "unknown"


def format_time(seconds: int | str) -> str:
    """Format seconds as MM:SS.

    Args:
        seconds: Time in seconds as int or string.

    Returns:
        Formatted time string.
    """
    try:
        total_seconds = int(float(seconds))
        minutes = total_seconds // 60
        secs = total_seconds % 60
        return f"{minutes}:{secs:02d}"
    except (ValueError, TypeError):
        return "0:00"


def truncate(text: str, max_length: int) -> str:
    """Truncate text to max_length with ellipsis if needed.

    Args:
        text: Text to truncate.
        max_length: Maximum length.

    Returns:
        Truncated text.
    """
    if len(text) <= max_length:
        return text
    return text[: max_length - 3] + "..."


def calculate_progress(elapsed: float, duration: float, bar_length: int) -> int:
    """Calculate number of filled blocks in progress bar.

    Args:
        elapsed: Current playback position in seconds.
        duration: Total track duration in seconds.
        bar_length: Total length of progress bar in characters.

    Returns:
        Number of filled blocks (0 to bar_length).
    """
    # Handle edge cases
    if duration <= 0:
        return 0
    if elapsed <= 0:
        return 0
    if elapsed >= duration:
        return bar_length

    # Calculate filled portion
    progress_ratio = elapsed / duration
    filled_blocks = int(progress_ratio * bar_length)

    # Ensure within bounds
    return max(0, min(filled_blocks, bar_length))


def render_progress_bar(filled: int, total_length: int, style: str = "blocks") -> str:
    """Render progress bar with specified style.

    Args:
        filled: Number of filled blocks.
        total_length: Total bar length in characters.
        style: Bar style - 'blocks', 'smooth', or 'simple'.

    Returns:
        Rendered progress bar string.
    """
    # Define style characters
    styles = {
        "blocks": {"filled": "█", "empty": "░"},
        "smooth": {"filled": "▰", "empty": "▱"},
        "simple": {"filled": "#", "empty": "-"},
    }

    # Get characters for the specified style (default to blocks if unknown)
    chars = styles.get(style, styles["blocks"])
    filled_char = chars["filled"]
    empty_char = chars["empty"]

    # Ensure filled is within bounds
    filled = max(0, min(filled, total_length))
    empty = total_length - filled

    # Build the bar
    return filled_char * filled + empty_char * empty


def get_playlist_context(client: MPDClient) -> dict:
    """Get playlist context including current position and adjacent tracks.

    Args:
        client: Connected MPDClient instance.

    Returns:
        Dictionary with keys:
        - 'current_pos': Current track position (1-indexed) or None
        - 'total': Total tracks in playlist or None
        - 'next': Dict with 'artist' and 'title' for next track, or None
        - 'prev': Dict with 'artist' and 'title' for previous track, or None
    """
    try:
        status = client.status()
        current_song = client.currentsong()

        # Get current position (0-indexed in MPD, convert to 1-indexed)
        song_pos = status.get("song")
        if song_pos is None:
            return {"current_pos": None, "total": None, "next": None, "prev": None}

        current_pos = int(song_pos) + 1  # Convert to 1-indexed

        # Get playlist length
        playlist_length = int(status.get("playlistlength", 0))

        # Initialize adjacent track info
        next_track = None
        prev_track = None

        # Get next track info if not the last song
        if current_pos < playlist_length:
            next_song_info = client.playlistinfo(str(int(song_pos) + 1))
            if next_song_info:
                next_track = {
                    "artist": next_song_info[0].get("artist", "Unknown"),
                    "title": next_song_info[0].get("title", "Unknown"),
                }

        # Get previous track info if not the first song
        if current_pos > 1:
            prev_song_info = client.playlistinfo(str(int(song_pos) - 1))
            if prev_song_info:
                prev_track = {
                    "artist": prev_song_info[0].get("artist", "Unknown"),
                    "title": prev_song_info[0].get("title", "Unknown"),
                }

        return {
            "current_pos": current_pos,
            "total": playlist_length,
            "next": next_track,
            "prev": prev_track,
        }

    except Exception:
        # If any error occurs, return empty context
        return {"current_pos": None, "total": None, "next": None, "prev": None}


def get_sync_status(file_path: str) -> str:
    """Check if a YouTube track's stream URL is resolved in the database.

    Args:
        file_path: File path from MPD currentsong (file field).

    Returns:
        Status string: 'resolved', 'unresolved', 'local', or 'unknown'
    """
    # Not a YouTube proxy URL - must be local
    if not file_path.startswith("http://localhost:6602/proxy/"):
        return "local"

    # Extract video ID from proxy URL
    video_id = file_path.replace("http://localhost:6602/proxy/", "")

    # Check database
    db_path = Path.home() / ".config" / "ytmpd" / "track_mapping.db"
    if not db_path.exists():
        return "unknown"

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Check if stream_url is NULL (unresolved)
        cursor.execute(
            "SELECT stream_url FROM tracks WHERE video_id = ?",
            (video_id,)
        )
        result = cursor.fetchone()
        conn.close()

        if result is None:
            # Video ID not in database
            return "unknown"

        stream_url = result[0]
        if stream_url is None:
            # Stream URL is NULL - unresolved
            return "unresolved"
        else:
            # Stream URL exists - resolved
            return "resolved"

    except (sqlite3.Error, OSError):
        return "unknown"


def smart_truncate(text: str, max_length: int) -> str:
    """Truncate text intelligently, preserving important parts.

    Attempts to truncate from the middle of long titles while preserving
    artist names and using proper ellipsis character.

    Args:
        text: Text to truncate.
        max_length: Maximum length.

    Returns:
        Truncated text with proper ellipsis (…) if needed.
    """
    if len(text) <= max_length:
        return text

    # Use proper ellipsis character
    ellipsis = "…"

    # Try to find " - " separator (between artist and title)
    separator_pos = text.find(" - ")

    if separator_pos == -1 or separator_pos > max_length - 10:
        # No separator or artist name is too long
        # Just truncate from the end
        return text[: max_length - 1] + ellipsis

    # We have an artist - title structure
    artist = text[:separator_pos]
    rest = text[separator_pos:]  # Includes " - " and title

    # If artist alone is too long, truncate it
    if len(artist) > max_length - 10:
        return artist[: max_length - 1] + ellipsis

    # Calculate space available for title part
    available_for_rest = max_length - len(artist) - 1  # -1 for ellipsis

    if len(rest) <= available_for_rest:
        return text  # Should not happen given outer check, but safety

    # Truncate the title part, preserving artist
    # Try to truncate from middle of title if possible
    title_part = rest[3:]  # Remove " - "
    if len(title_part) > 20:
        # Long title - truncate from middle
        keep_start = (available_for_rest - 4) // 2  # -4 for " - " and ellipsis
        keep_end = available_for_rest - 4 - keep_start
        truncated_title = title_part[:keep_start] + ellipsis + title_part[-keep_end:]
        return f"{artist} - {truncated_title}"
    else:
        # Short title - truncate from end
        max_title_len = available_for_rest - 3  # -3 for " - "
        truncated_title = title_part[:max_title_len - 1] + ellipsis
        return f"{artist} - {truncated_title}"


def validate_color(color: str) -> str:
    """Validate hex color format.

    Args:
        color: Color string to validate (e.g., "#FF6B35").

    Returns:
        Validated color string.

    Raises:
        argparse.ArgumentTypeError: If color format is invalid.
    """
    if not re.match(r"^#[0-9A-Fa-f]{6}$", color):
        raise argparse.ArgumentTypeError(
            f"Invalid color format: {color}. Expected format: #RRGGBB"
        )
    return color


def validate_port(value: str) -> int:
    """Validate port number.

    Args:
        value: Port number as string.

    Returns:
        Validated port as int.

    Raises:
        argparse.ArgumentTypeError: If port is out of range.
    """
    try:
        port = int(value)
        if not 1 <= port <= 65535:
            raise ValueError
        return port
    except ValueError:
        raise argparse.ArgumentTypeError(
            f"Invalid port: {value}. Must be between 1 and 65535"
        )


def validate_positive_int(value: str, min_val: int, max_val: int, name: str) -> int:
    """Validate positive integer within range.

    Args:
        value: Value as string.
        min_val: Minimum allowed value.
        max_val: Maximum allowed value.
        name: Name of parameter for error message.

    Returns:
        Validated integer.

    Raises:
        argparse.ArgumentTypeError: If value is out of range.
    """
    try:
        val = int(value)
        if not min_val <= val <= max_val:
            raise ValueError
        return val
    except ValueError:
        raise argparse.ArgumentTypeError(
            f"Invalid {name}: {value}. Must be between {min_val} and {max_val}"
        )


def parse_arguments() -> argparse.Namespace:
    """Parse command-line arguments with backward compatibility for env vars.

    Returns:
        Parsed arguments namespace.
    """
    parser = argparse.ArgumentParser(
        prog="ytmpd-status",
        description="Display ytmpd/MPD status for i3blocks with YouTube track detection",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Format String Placeholders:
  {icon}      - Playback status icon (▶, ⏸, ⏹)
  {artist}    - Track artist
  {title}     - Track title
  {album}     - Album name
  {elapsed}   - Elapsed time (formatted as M:SS)
  {duration}  - Total duration (formatted as M:SS)
  {bar}       - Progress bar
  {position}  - Current track position in playlist
  {total}     - Total tracks in playlist
  {next}      - Next track (if available)
  {prev}      - Previous track (if available)

Examples:
  ytmpd-status
  ytmpd-status --compact --no-show-bar
  ytmpd-status --format "{icon} {title} ({elapsed}/{duration})"
  ytmpd-status --bar-length 15 --show-next
  ytmpd-status --host localhost --port 6600
        """,
    )

    # Version
    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
    )

    # Connection options
    conn_group = parser.add_argument_group("Connection Options")
    conn_group.add_argument(
        "--host",
        default=os.environ.get("YTMPD_STATUS_HOST", "localhost"),
        help="MPD server host (default: localhost)",
    )
    conn_group.add_argument(
        "--port",
        type=validate_port,
        default=int(os.environ.get("YTMPD_STATUS_PORT", "6601")),
        help="MPD server port (default: 6601)",
    )

    # Display options
    display_group = parser.add_argument_group("Display Options")
    display_group.add_argument(
        "-l",
        "--max-length",
        type=lambda x: validate_positive_int(x, 1, 200, "max-length"),
        default=int(os.environ.get("YTMPD_STATUS_MAX_LENGTH", "50")),
        help="Maximum output length (default: 50)",
    )
    display_group.add_argument(
        "-f",
        "--format",
        default=os.environ.get("YTMPD_STATUS_FORMAT", ""),
        help="Custom format string (default: auto)",
    )
    display_group.add_argument(
        "-c",
        "--compact",
        action="store_true",
        default=os.environ.get("YTMPD_STATUS_COMPACT", "false").lower()
        in ("true", "1", "yes"),
        help="Use compact display mode",
    )

    # Progress bar options
    bar_group = parser.add_argument_group("Progress Bar Options")
    bar_group.add_argument(
        "--show-bar",
        action="store_true",
        dest="show_bar",
        default=None,
        help="Enable progress bar (default)",
    )
    bar_group.add_argument(
        "--no-show-bar",
        action="store_false",
        dest="show_bar",
        help="Disable progress bar",
    )
    bar_group.add_argument(
        "--bar-length",
        type=lambda x: validate_positive_int(x, 1, 50, "bar-length"),
        default=int(os.environ.get("YTMPD_STATUS_BAR_LENGTH", "10")),
        help="Progress bar length in characters (default: 10)",
    )
    bar_group.add_argument(
        "--bar-style",
        choices=["blocks", "smooth", "simple", "auto"],
        default=os.environ.get("YTMPD_STATUS_BAR_STYLE", "auto"),
        help="Progress bar style (default: auto)",
    )

    # Playlist context options
    playlist_group = parser.add_argument_group("Playlist Context Options")
    playlist_group.add_argument(
        "--show-next",
        action="store_true",
        default=os.environ.get("YTMPD_STATUS_SHOW_NEXT", "false").lower()
        in ("true", "1", "yes"),
        help="Show next track",
    )
    playlist_group.add_argument(
        "--show-prev",
        action="store_true",
        default=os.environ.get("YTMPD_STATUS_SHOW_PREV", "false").lower()
        in ("true", "1", "yes"),
        help="Show previous track",
    )
    playlist_group.add_argument(
        "--show-position",
        action="store_true",
        default=os.environ.get("YTMPD_STATUS_SHOW_POSITION", "false").lower()
        in ("true", "1", "yes"),
        help="Show playlist position",
    )

    # Color options
    color_group = parser.add_argument_group("Color Options")
    color_group.add_argument(
        "--color-youtube-playing",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_YOUTUBE_PLAYING", "#FF6B35"),
        help="Color for YouTube playing (default: #FF6B35)",
    )
    color_group.add_argument(
        "--color-youtube-paused",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_YOUTUBE_PAUSED", "#FFB84D"),
        help="Color for YouTube paused (default: #FFB84D)",
    )
    color_group.add_argument(
        "--color-local-playing",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_LOCAL_PLAYING", "#00FF00"),
        help="Color for local playing (default: #00FF00)",
    )
    color_group.add_argument(
        "--color-local-paused",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_LOCAL_PAUSED", "#FFFF00"),
        help="Color for local paused (default: #FFFF00)",
    )
    color_group.add_argument(
        "--color-stopped",
        type=validate_color,
        default=os.environ.get("YTMPD_STATUS_COLOR_STOPPED", "#808080"),
        help="Color for stopped (default: #808080)",
    )

    # Icon options
    icon_group = parser.add_argument_group("Icon Options")
    icon_group.add_argument(
        "--icon-playing",
        default=os.environ.get("YTMPD_STATUS_ICON_PLAYING", "▶"),
        help="Icon for playing state (default: ▶)",
    )
    icon_group.add_argument(
        "--icon-paused",
        default=os.environ.get("YTMPD_STATUS_ICON_PAUSED", "⏸"),
        help="Icon for paused state (default: ⏸)",
    )
    icon_group.add_argument(
        "--icon-stopped",
        default=os.environ.get("YTMPD_STATUS_ICON_STOPPED", "⏹"),
        help="Icon for stopped state (default: ⏹)",
    )

    # Debug options
    debug_group = parser.add_argument_group("Debug Options")
    debug_group.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Verbose output (show connection info, etc.)",
    )

    args = parser.parse_args()

    # Handle show_bar default (backward compatibility)
    if args.show_bar is None:
        # Not specified on CLI, check env var
        args.show_bar = os.environ.get("YTMPD_STATUS_SHOW_BAR", "true").lower() in (
            "true",
            "1",
            "yes",
        )

    # Convert bar_style "auto" to empty string for consistency with old code
    if args.bar_style == "auto":
        args.bar_style = ""

    return args


def format_with_template(template: str, data: dict) -> str:
    """Format output using template string with placeholders.

    Args:
        template: Format string with {placeholder} syntax.
        data: Dictionary with placeholder values.

    Returns:
        Formatted string.
    """
    # Replace placeholders with values
    output = template
    for key, value in data.items():
        placeholder = f"{{{key}}}"
        if placeholder in output:
            output = output.replace(placeholder, str(value) if value is not None else "")

    return output


def main() -> None:
    """Display MPD/ytmpd status for i3blocks."""
    # Parse arguments (with backward compatibility for env vars)
    args = parse_arguments()

    # Extract configuration from args
    max_length = args.max_length
    bar_length = args.bar_length
    show_bar = args.show_bar
    bar_style = args.bar_style
    show_next = args.show_next
    show_prev = args.show_prev
    compact_mode = args.compact
    custom_format = args.format

    if args.verbose:
        print(f"Connecting to MPD at {args.host}:{args.port}", file=sys.stderr)

    # Connect to MPD
    client = get_mpd_client(host=args.host, port=args.port)

    if client is None:
        # MPD not running
        stop_icon = args.icon_stopped
        stop_color = args.color_stopped
        print(f"{stop_icon} MPD stopped")
        print(f"{stop_icon} MPD stopped")  # Short text
        print(stop_color)
        sys.exit(0)

    try:
        # Get current status and song
        status = client.status()
        current_song = client.currentsong()

        state = status.get("state", "stop")

        if state == "stop" or not current_song:
            stop_icon = args.icon_stopped
            stop_color = args.color_stopped
            print(f"{stop_icon} Stopped")
            print(f"{stop_icon} Stopped")  # Short text
            print(stop_color)
            client.close()
            sys.exit(0)

        # Get song info
        title = current_song.get("title", "Unknown")
        artist = current_song.get("artist", "Unknown")
        file_path = current_song.get("file", "")

        # Get timing info
        elapsed = status.get("elapsed", "0")
        duration = status.get("duration", current_song.get("time", "0"))

        # Format time
        position_str = format_time(elapsed)
        duration_str = format_time(duration)

        # Classify track type
        track_type = get_track_type(file_path)

        # Choose icon and color based on state and track type
        if state == "play":
            icon = args.icon_playing
            if track_type == "youtube":
                color = args.color_youtube_playing
            else:
                color = args.color_local_playing
        elif state == "pause":
            icon = args.icon_paused
            if track_type == "youtube":
                color = args.color_youtube_paused
            else:
                color = args.color_local_paused
        else:
            icon = args.icon_stopped
            color = args.color_stopped

        # Get playlist context
        playlist_ctx = get_playlist_context(client)

        # Check sync status for YouTube tracks
        sync_status = get_sync_status(file_path)

        # Check if using custom format string
        if custom_format:
            # Build progress bar if needed in format
            progress_bar_str = ""
            if "{bar}" in custom_format and show_bar:
                try:
                    elapsed_float = float(elapsed)
                    duration_float = float(duration)
                    if duration_float > 0:
                        style = bar_style if bar_style else ("smooth" if track_type == "youtube" else "blocks")
                        filled_blocks = calculate_progress(elapsed_float, duration_float, bar_length)
                        progress_bar_str = render_progress_bar(filled_blocks, bar_length, style)
                except (ValueError, TypeError):
                    pass

            # Prepare data for template
            template_data = {
                "icon": icon,
                "artist": artist,
                "title": title,
                "album": current_song.get("album", ""),
                "elapsed": position_str,
                "duration": duration_str,
                "bar": progress_bar_str,
                "position": playlist_ctx["current_pos"] if playlist_ctx["current_pos"] else "",
                "total": playlist_ctx["total"] if playlist_ctx["total"] else "",
                "next": f"{playlist_ctx['next']['artist']} - {playlist_ctx['next']['title']}" if playlist_ctx["next"] else "",
                "prev": f"{playlist_ctx['prev']['artist']} - {playlist_ctx['prev']['title']}" if playlist_ctx["prev"] else "",
            }

            # Format using template
            output = format_with_template(custom_format, template_data)

        # Build output based on mode
        elif compact_mode:
            # Compact mode: just icon, artist, and title
            output = f"{icon} {artist} - {title}"
        else:
            # Build progress bar if enabled
            progress_bar_str = ""
            if show_bar:
                # Convert elapsed and duration to float for calculation
                try:
                    elapsed_float = float(elapsed)
                    duration_float = float(duration)

                    # Only show bar if we have a valid duration
                    if duration_float > 0:
                        # Determine bar style (auto-detect based on track type if not specified)
                        if bar_style:
                            style = bar_style
                        else:
                            style = "smooth" if track_type == "youtube" else "blocks"

                        # Calculate and render progress bar
                        filled_blocks = calculate_progress(elapsed_float, duration_float, bar_length)
                        progress_bar_str = " " + render_progress_bar(filled_blocks, bar_length, style)
                except (ValueError, TypeError):
                    # If timing info is invalid, don't show bar
                    pass

            # Build context-aware suffix
            context_suffix = ""
            if sync_status == "unresolved":
                # YouTube track not yet resolved
                context_suffix = " [Resolving...]"
            elif playlist_ctx["current_pos"] is not None and playlist_ctx["total"] is not None:
                pos = playlist_ctx["current_pos"]
                total = playlist_ctx["total"]
                # Show position for first, last, or single track
                if total == 1:
                    context_suffix = " [1/1]"
                elif pos == 1:
                    context_suffix = f" [1/{total}]"
                elif pos == total:
                    context_suffix = f" [{total}/{total}]"

            # Build main output string
            output = f"{icon} {artist} - {title} [{position_str}{progress_bar_str} {duration_str}]{context_suffix}"

        # Truncate if needed (use smart truncation)
        output = smart_truncate(output, max_length)

        # Build additional lines for next/previous tracks if enabled
        additional_lines = []

        if show_prev and playlist_ctx["prev"] is not None:
            prev = playlist_ctx["prev"]
            prev_line = f"↑ {prev['artist']} - {prev['title']}"
            prev_line = smart_truncate(prev_line, max_length)
            additional_lines.append(prev_line)

        if show_next and playlist_ctx["next"] is not None:
            next_track = playlist_ctx["next"]
            next_line = f"↓ {next_track['artist']} - {next_track['title']}"
            next_line = smart_truncate(next_line, max_length)
            additional_lines.append(next_line)

        # Output for i3blocks
        # If we have additional lines, append them to the full text
        if additional_lines:
            full_output = output + "\n" + "\n".join(additional_lines)
        else:
            full_output = output

        print(full_output)  # Full text (may include next/prev)
        print(output)  # Short text (just main line)
        print(color)  # Color

    except Exception as e:
        # Unexpected error
        stop_icon = args.icon_stopped
        stop_color = args.color_stopped
        print(f"{stop_icon} Error: {e}")
        print(f"{stop_icon} Error")
        print(stop_color)
    finally:
        if client:
            client.close()


if __name__ == "__main__":
    main()
