#!/usr/bin/env python3
"""ytmpd-status - i3blocks status script for ytmpd.

This script queries MPD status and formats it for i3blocks display,
with special handling for YouTube-streamed vs local tracks.

Environment Variables:
    YTMPD_STATUS_MAX_LENGTH: Maximum length before truncation (default: 50)
    YTMPD_STATUS_BAR_LENGTH: Progress bar length in characters (default: 10)
    YTMPD_STATUS_SHOW_BAR: Enable/disable progress bar (default: true)
    YTMPD_STATUS_BAR_STYLE: Force specific bar style - 'blocks', 'smooth', or 'simple'
                            (default: auto-detect based on track type)

Progress Bar Styles:
    blocks: █████░░░░░ (used for local tracks)
    smooth: ▰▰▰▰▰▱▱▱▱▱ (used for YouTube tracks)
    simple: #####----- (ASCII fallback)

Color Codes (for i3blocks):
    YouTube Playing: #FF6B35 (orange)
    YouTube Paused: #FFB84D (light orange)
    Local Playing: #00FF00 (green)
    Local Paused: #FFFF00 (yellow)
    Stopped: #808080 (gray)
"""

import os
import sqlite3
import sys
from pathlib import Path

from mpd import MPDClient, ConnectionError as MPDConnectionError


def get_mpd_client(host: str = "localhost", port: int = 6601) -> MPDClient | None:
    """Connect to MPD server and return client.

    Args:
        host: MPD server hostname (default: localhost)
        port: MPD server port (default: 6601)

    Returns:
        MPDClient instance if connected, None if connection failed.
    """
    try:
        client = MPDClient()
        client.connect(host, port)
        return client
    except (MPDConnectionError, ConnectionRefusedError, OSError):
        return None


def get_track_type(file_path: str) -> str:
    """Determine if track is a YouTube stream or local file.

    Args:
        file_path: File path from MPD currentsong (file field).

    Returns:
        'youtube', 'local', or 'unknown'
    """
    # Check if it's a YouTube proxy stream
    if file_path.startswith("http://localhost:6602/proxy/"):
        return "youtube"

    # Check ytmpd database for additional YouTube tracks
    db_path = Path.home() / ".config" / "ytmpd" / "track_mapping.db"
    if not db_path.exists():
        # No database, assume local if not a proxy URL
        return "local" if not file_path.startswith("http") else "unknown"

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Query for this file path
        cursor.execute(
            "SELECT COUNT(*) FROM tracks WHERE file = ?",
            (file_path,)
        )
        count = cursor.fetchone()[0]
        conn.close()

        if count > 0:
            return "youtube"

        # Not in database - assume local
        return "local" if not file_path.startswith("http") else "unknown"

    except (sqlite3.Error, OSError):
        # Database error - fall back to heuristic
        return "local" if not file_path.startswith("http") else "unknown"


def format_time(seconds: int | str) -> str:
    """Format seconds as MM:SS.

    Args:
        seconds: Time in seconds as int or string.

    Returns:
        Formatted time string.
    """
    try:
        total_seconds = int(float(seconds))
        minutes = total_seconds // 60
        secs = total_seconds % 60
        return f"{minutes}:{secs:02d}"
    except (ValueError, TypeError):
        return "0:00"


def truncate(text: str, max_length: int) -> str:
    """Truncate text to max_length with ellipsis if needed.

    Args:
        text: Text to truncate.
        max_length: Maximum length.

    Returns:
        Truncated text.
    """
    if len(text) <= max_length:
        return text
    return text[: max_length - 3] + "..."


def calculate_progress(elapsed: float, duration: float, bar_length: int) -> int:
    """Calculate number of filled blocks in progress bar.

    Args:
        elapsed: Current playback position in seconds.
        duration: Total track duration in seconds.
        bar_length: Total length of progress bar in characters.

    Returns:
        Number of filled blocks (0 to bar_length).
    """
    # Handle edge cases
    if duration <= 0:
        return 0
    if elapsed <= 0:
        return 0
    if elapsed >= duration:
        return bar_length

    # Calculate filled portion
    progress_ratio = elapsed / duration
    filled_blocks = int(progress_ratio * bar_length)

    # Ensure within bounds
    return max(0, min(filled_blocks, bar_length))


def render_progress_bar(filled: int, total_length: int, style: str = "blocks") -> str:
    """Render progress bar with specified style.

    Args:
        filled: Number of filled blocks.
        total_length: Total bar length in characters.
        style: Bar style - 'blocks', 'smooth', or 'simple'.

    Returns:
        Rendered progress bar string.
    """
    # Define style characters
    styles = {
        "blocks": {"filled": "█", "empty": "░"},
        "smooth": {"filled": "▰", "empty": "▱"},
        "simple": {"filled": "#", "empty": "-"},
    }

    # Get characters for the specified style (default to blocks if unknown)
    chars = styles.get(style, styles["blocks"])
    filled_char = chars["filled"]
    empty_char = chars["empty"]

    # Ensure filled is within bounds
    filled = max(0, min(filled, total_length))
    empty = total_length - filled

    # Build the bar
    return filled_char * filled + empty_char * empty


def main() -> None:
    """Display MPD/ytmpd status for i3blocks."""
    # Get configuration from environment
    max_length = int(os.environ.get("YTMPD_STATUS_MAX_LENGTH", "50"))
    bar_length = int(os.environ.get("YTMPD_STATUS_BAR_LENGTH", "10"))
    show_bar = os.environ.get("YTMPD_STATUS_SHOW_BAR", "true").lower() in ("true", "1", "yes")
    bar_style = os.environ.get("YTMPD_STATUS_BAR_STYLE", "")  # Empty means auto-detect

    # Connect to MPD
    client = get_mpd_client()

    if client is None:
        # MPD not running
        print("⏹ MPD stopped")
        print("⏹ MPD stopped")  # Short text
        print("#808080")  # Gray color
        sys.exit(0)

    try:
        # Get current status and song
        status = client.status()
        current_song = client.currentsong()

        state = status.get("state", "stop")

        if state == "stop" or not current_song:
            print("⏹ Stopped")
            print("⏹ Stopped")  # Short text
            print("#808080")  # Gray color
            client.close()
            sys.exit(0)

        # Get song info
        title = current_song.get("title", "Unknown")
        artist = current_song.get("artist", "Unknown")
        file_path = current_song.get("file", "")

        # Get timing info
        elapsed = status.get("elapsed", "0")
        duration = status.get("duration", current_song.get("time", "0"))

        # Format time
        position_str = format_time(elapsed)
        duration_str = format_time(duration)

        # Classify track type
        track_type = get_track_type(file_path)

        # Choose icon and color based on state and track type
        if state == "play":
            icon = "▶"
            if track_type == "youtube":
                color = "#FF6B35"  # Orange for YouTube
            else:
                color = "#00FF00"  # Green for local
        elif state == "pause":
            icon = "⏸"
            if track_type == "youtube":
                color = "#FFB84D"  # Light orange for YouTube paused
            else:
                color = "#FFFF00"  # Yellow for local paused
        else:
            icon = "⏹"
            color = "#808080"  # Gray for stopped

        # Build progress bar if enabled
        progress_bar_str = ""
        if show_bar:
            # Convert elapsed and duration to float for calculation
            try:
                elapsed_float = float(elapsed)
                duration_float = float(duration)

                # Only show bar if we have a valid duration
                if duration_float > 0:
                    # Determine bar style (auto-detect based on track type if not specified)
                    if bar_style:
                        style = bar_style
                    else:
                        style = "smooth" if track_type == "youtube" else "blocks"

                    # Calculate and render progress bar
                    filled_blocks = calculate_progress(elapsed_float, duration_float, bar_length)
                    progress_bar_str = " " + render_progress_bar(filled_blocks, bar_length, style)
            except (ValueError, TypeError):
                # If timing info is invalid, don't show bar
                pass

        # Build output string
        output = f"{icon} {artist} - {title} [{position_str}{progress_bar_str} {duration_str}]"

        # Truncate if needed
        output = truncate(output, max_length)

        # Output for i3blocks
        print(output)  # Full text
        print(output)  # Short text (same as full for now)
        print(color)  # Color

    except Exception as e:
        # Unexpected error
        print(f"⏹ Error: {e}")
        print("⏹ Error")
        print("#808080")
    finally:
        if client:
            client.close()


if __name__ == "__main__":
    main()
