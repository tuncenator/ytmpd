#!/usr/bin/env python3
"""ytmpd-status - i3blocks status script for ytmpd.

This script queries MPD status and formats it for i3blocks display,
with special handling for YouTube-streamed vs local tracks.

Environment Variables:
    YTMPD_STATUS_MAX_LENGTH: Maximum length before truncation (default: 50)
    YTMPD_STATUS_BAR_LENGTH: Progress bar length in characters (default: 10)
    YTMPD_STATUS_SHOW_BAR: Enable/disable progress bar (default: true)
    YTMPD_STATUS_BAR_STYLE: Force specific bar style - 'blocks', 'smooth', or 'simple'
                            (default: auto-detect based on track type)
    YTMPD_STATUS_SHOW_NEXT: Show next track info (default: false)
    YTMPD_STATUS_SHOW_PREV: Show previous track info (default: false)
    YTMPD_STATUS_COMPACT: Minimal output mode (default: false)

Progress Bar Styles:
    blocks: █████░░░░░ (used for local tracks)
    smooth: ▰▰▰▰▰▱▱▱▱▱ (used for YouTube tracks)
    simple: #####----- (ASCII fallback)

Color Codes (for i3blocks):
    YouTube Playing: #FF6B35 (orange)
    YouTube Paused: #FFB84D (light orange)
    Local Playing: #00FF00 (green)
    Local Paused: #FFFF00 (yellow)
    Stopped: #808080 (gray)
"""

import os
import sqlite3
import sys
from pathlib import Path

from mpd import MPDClient, ConnectionError as MPDConnectionError


def get_mpd_client(host: str = "localhost", port: int = 6601) -> MPDClient | None:
    """Connect to MPD server and return client.

    Args:
        host: MPD server hostname (default: localhost)
        port: MPD server port (default: 6601)

    Returns:
        MPDClient instance if connected, None if connection failed.
    """
    try:
        client = MPDClient()
        client.connect(host, port)
        return client
    except (MPDConnectionError, ConnectionRefusedError, OSError):
        return None


def get_track_type(file_path: str) -> str:
    """Determine if track is a YouTube stream or local file.

    Args:
        file_path: File path from MPD currentsong (file field).

    Returns:
        'youtube', 'local', or 'unknown'
    """
    # Check if it's a YouTube proxy stream
    if file_path.startswith("http://localhost:6602/proxy/"):
        return "youtube"

    # Check ytmpd database for additional YouTube tracks
    db_path = Path.home() / ".config" / "ytmpd" / "track_mapping.db"
    if not db_path.exists():
        # No database, assume local if not a proxy URL
        return "local" if not file_path.startswith("http") else "unknown"

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Query for this file path
        cursor.execute(
            "SELECT COUNT(*) FROM tracks WHERE file = ?",
            (file_path,)
        )
        count = cursor.fetchone()[0]
        conn.close()

        if count > 0:
            return "youtube"

        # Not in database - assume local
        return "local" if not file_path.startswith("http") else "unknown"

    except (sqlite3.Error, OSError):
        # Database error - fall back to heuristic
        return "local" if not file_path.startswith("http") else "unknown"


def format_time(seconds: int | str) -> str:
    """Format seconds as MM:SS.

    Args:
        seconds: Time in seconds as int or string.

    Returns:
        Formatted time string.
    """
    try:
        total_seconds = int(float(seconds))
        minutes = total_seconds // 60
        secs = total_seconds % 60
        return f"{minutes}:{secs:02d}"
    except (ValueError, TypeError):
        return "0:00"


def truncate(text: str, max_length: int) -> str:
    """Truncate text to max_length with ellipsis if needed.

    Args:
        text: Text to truncate.
        max_length: Maximum length.

    Returns:
        Truncated text.
    """
    if len(text) <= max_length:
        return text
    return text[: max_length - 3] + "..."


def calculate_progress(elapsed: float, duration: float, bar_length: int) -> int:
    """Calculate number of filled blocks in progress bar.

    Args:
        elapsed: Current playback position in seconds.
        duration: Total track duration in seconds.
        bar_length: Total length of progress bar in characters.

    Returns:
        Number of filled blocks (0 to bar_length).
    """
    # Handle edge cases
    if duration <= 0:
        return 0
    if elapsed <= 0:
        return 0
    if elapsed >= duration:
        return bar_length

    # Calculate filled portion
    progress_ratio = elapsed / duration
    filled_blocks = int(progress_ratio * bar_length)

    # Ensure within bounds
    return max(0, min(filled_blocks, bar_length))


def render_progress_bar(filled: int, total_length: int, style: str = "blocks") -> str:
    """Render progress bar with specified style.

    Args:
        filled: Number of filled blocks.
        total_length: Total bar length in characters.
        style: Bar style - 'blocks', 'smooth', or 'simple'.

    Returns:
        Rendered progress bar string.
    """
    # Define style characters
    styles = {
        "blocks": {"filled": "█", "empty": "░"},
        "smooth": {"filled": "▰", "empty": "▱"},
        "simple": {"filled": "#", "empty": "-"},
    }

    # Get characters for the specified style (default to blocks if unknown)
    chars = styles.get(style, styles["blocks"])
    filled_char = chars["filled"]
    empty_char = chars["empty"]

    # Ensure filled is within bounds
    filled = max(0, min(filled, total_length))
    empty = total_length - filled

    # Build the bar
    return filled_char * filled + empty_char * empty


def get_playlist_context(client: MPDClient) -> dict:
    """Get playlist context including current position and adjacent tracks.

    Args:
        client: Connected MPDClient instance.

    Returns:
        Dictionary with keys:
        - 'current_pos': Current track position (1-indexed) or None
        - 'total': Total tracks in playlist or None
        - 'next': Dict with 'artist' and 'title' for next track, or None
        - 'prev': Dict with 'artist' and 'title' for previous track, or None
    """
    try:
        status = client.status()
        current_song = client.currentsong()

        # Get current position (0-indexed in MPD, convert to 1-indexed)
        song_pos = status.get("song")
        if song_pos is None:
            return {"current_pos": None, "total": None, "next": None, "prev": None}

        current_pos = int(song_pos) + 1  # Convert to 1-indexed

        # Get playlist length
        playlist_length = int(status.get("playlistlength", 0))

        # Initialize adjacent track info
        next_track = None
        prev_track = None

        # Get next track info if not the last song
        if current_pos < playlist_length:
            next_song_info = client.playlistinfo(str(int(song_pos) + 1))
            if next_song_info:
                next_track = {
                    "artist": next_song_info[0].get("artist", "Unknown"),
                    "title": next_song_info[0].get("title", "Unknown"),
                }

        # Get previous track info if not the first song
        if current_pos > 1:
            prev_song_info = client.playlistinfo(str(int(song_pos) - 1))
            if prev_song_info:
                prev_track = {
                    "artist": prev_song_info[0].get("artist", "Unknown"),
                    "title": prev_song_info[0].get("title", "Unknown"),
                }

        return {
            "current_pos": current_pos,
            "total": playlist_length,
            "next": next_track,
            "prev": prev_track,
        }

    except Exception:
        # If any error occurs, return empty context
        return {"current_pos": None, "total": None, "next": None, "prev": None}


def get_sync_status(file_path: str) -> str:
    """Check if a YouTube track's stream URL is resolved in the database.

    Args:
        file_path: File path from MPD currentsong (file field).

    Returns:
        Status string: 'resolved', 'unresolved', 'local', or 'unknown'
    """
    # Not a YouTube proxy URL - must be local
    if not file_path.startswith("http://localhost:6602/proxy/"):
        return "local"

    # Extract video ID from proxy URL
    video_id = file_path.replace("http://localhost:6602/proxy/", "")

    # Check database
    db_path = Path.home() / ".config" / "ytmpd" / "track_mapping.db"
    if not db_path.exists():
        return "unknown"

    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Check if stream_url is NULL (unresolved)
        cursor.execute(
            "SELECT stream_url FROM tracks WHERE video_id = ?",
            (video_id,)
        )
        result = cursor.fetchone()
        conn.close()

        if result is None:
            # Video ID not in database
            return "unknown"

        stream_url = result[0]
        if stream_url is None:
            # Stream URL is NULL - unresolved
            return "unresolved"
        else:
            # Stream URL exists - resolved
            return "resolved"

    except (sqlite3.Error, OSError):
        return "unknown"


def smart_truncate(text: str, max_length: int) -> str:
    """Truncate text intelligently, preserving important parts.

    Attempts to truncate from the middle of long titles while preserving
    artist names and using proper ellipsis character.

    Args:
        text: Text to truncate.
        max_length: Maximum length.

    Returns:
        Truncated text with proper ellipsis (…) if needed.
    """
    if len(text) <= max_length:
        return text

    # Use proper ellipsis character
    ellipsis = "…"

    # Try to find " - " separator (between artist and title)
    separator_pos = text.find(" - ")

    if separator_pos == -1 or separator_pos > max_length - 10:
        # No separator or artist name is too long
        # Just truncate from the end
        return text[: max_length - 1] + ellipsis

    # We have an artist - title structure
    artist = text[:separator_pos]
    rest = text[separator_pos:]  # Includes " - " and title

    # If artist alone is too long, truncate it
    if len(artist) > max_length - 10:
        return artist[: max_length - 1] + ellipsis

    # Calculate space available for title part
    available_for_rest = max_length - len(artist) - 1  # -1 for ellipsis

    if len(rest) <= available_for_rest:
        return text  # Should not happen given outer check, but safety

    # Truncate the title part, preserving artist
    # Try to truncate from middle of title if possible
    title_part = rest[3:]  # Remove " - "
    if len(title_part) > 20:
        # Long title - truncate from middle
        keep_start = (available_for_rest - 4) // 2  # -4 for " - " and ellipsis
        keep_end = available_for_rest - 4 - keep_start
        truncated_title = title_part[:keep_start] + ellipsis + title_part[-keep_end:]
        return f"{artist} - {truncated_title}"
    else:
        # Short title - truncate from end
        max_title_len = available_for_rest - 3  # -3 for " - "
        truncated_title = title_part[:max_title_len - 1] + ellipsis
        return f"{artist} - {truncated_title}"


def main() -> None:
    """Display MPD/ytmpd status for i3blocks."""
    # Get configuration from environment
    max_length = int(os.environ.get("YTMPD_STATUS_MAX_LENGTH", "50"))
    bar_length = int(os.environ.get("YTMPD_STATUS_BAR_LENGTH", "10"))
    show_bar = os.environ.get("YTMPD_STATUS_SHOW_BAR", "true").lower() in ("true", "1", "yes")
    bar_style = os.environ.get("YTMPD_STATUS_BAR_STYLE", "")  # Empty means auto-detect
    show_next = os.environ.get("YTMPD_STATUS_SHOW_NEXT", "false").lower() in ("true", "1", "yes")
    show_prev = os.environ.get("YTMPD_STATUS_SHOW_PREV", "false").lower() in ("true", "1", "yes")
    compact_mode = os.environ.get("YTMPD_STATUS_COMPACT", "false").lower() in ("true", "1", "yes")

    # Connect to MPD
    client = get_mpd_client()

    if client is None:
        # MPD not running
        print("⏹ MPD stopped")
        print("⏹ MPD stopped")  # Short text
        print("#808080")  # Gray color
        sys.exit(0)

    try:
        # Get current status and song
        status = client.status()
        current_song = client.currentsong()

        state = status.get("state", "stop")

        if state == "stop" or not current_song:
            print("⏹ Stopped")
            print("⏹ Stopped")  # Short text
            print("#808080")  # Gray color
            client.close()
            sys.exit(0)

        # Get song info
        title = current_song.get("title", "Unknown")
        artist = current_song.get("artist", "Unknown")
        file_path = current_song.get("file", "")

        # Get timing info
        elapsed = status.get("elapsed", "0")
        duration = status.get("duration", current_song.get("time", "0"))

        # Format time
        position_str = format_time(elapsed)
        duration_str = format_time(duration)

        # Classify track type
        track_type = get_track_type(file_path)

        # Choose icon and color based on state and track type
        if state == "play":
            icon = "▶"
            if track_type == "youtube":
                color = "#FF6B35"  # Orange for YouTube
            else:
                color = "#00FF00"  # Green for local
        elif state == "pause":
            icon = "⏸"
            if track_type == "youtube":
                color = "#FFB84D"  # Light orange for YouTube paused
            else:
                color = "#FFFF00"  # Yellow for local paused
        else:
            icon = "⏹"
            color = "#808080"  # Gray for stopped

        # Get playlist context
        playlist_ctx = get_playlist_context(client)

        # Check sync status for YouTube tracks
        sync_status = get_sync_status(file_path)

        # Build output based on mode
        if compact_mode:
            # Compact mode: just icon, artist, and title
            output = f"{icon} {artist} - {title}"
        else:
            # Build progress bar if enabled
            progress_bar_str = ""
            if show_bar:
                # Convert elapsed and duration to float for calculation
                try:
                    elapsed_float = float(elapsed)
                    duration_float = float(duration)

                    # Only show bar if we have a valid duration
                    if duration_float > 0:
                        # Determine bar style (auto-detect based on track type if not specified)
                        if bar_style:
                            style = bar_style
                        else:
                            style = "smooth" if track_type == "youtube" else "blocks"

                        # Calculate and render progress bar
                        filled_blocks = calculate_progress(elapsed_float, duration_float, bar_length)
                        progress_bar_str = " " + render_progress_bar(filled_blocks, bar_length, style)
                except (ValueError, TypeError):
                    # If timing info is invalid, don't show bar
                    pass

            # Build context-aware suffix
            context_suffix = ""
            if sync_status == "unresolved":
                # YouTube track not yet resolved
                context_suffix = " [Resolving...]"
            elif playlist_ctx["current_pos"] is not None and playlist_ctx["total"] is not None:
                pos = playlist_ctx["current_pos"]
                total = playlist_ctx["total"]
                # Show position for first, last, or single track
                if total == 1:
                    context_suffix = " [1/1]"
                elif pos == 1:
                    context_suffix = f" [1/{total}]"
                elif pos == total:
                    context_suffix = f" [{total}/{total}]"

            # Build main output string
            output = f"{icon} {artist} - {title} [{position_str}{progress_bar_str} {duration_str}]{context_suffix}"

        # Truncate if needed (use smart truncation)
        output = smart_truncate(output, max_length)

        # Build additional lines for next/previous tracks if enabled
        additional_lines = []

        if show_prev and playlist_ctx["prev"] is not None:
            prev = playlist_ctx["prev"]
            prev_line = f"↑ {prev['artist']} - {prev['title']}"
            prev_line = smart_truncate(prev_line, max_length)
            additional_lines.append(prev_line)

        if show_next and playlist_ctx["next"] is not None:
            next_track = playlist_ctx["next"]
            next_line = f"↓ {next_track['artist']} - {next_track['title']}"
            next_line = smart_truncate(next_line, max_length)
            additional_lines.append(next_line)

        # Output for i3blocks
        # If we have additional lines, append them to the full text
        if additional_lines:
            full_output = output + "\n" + "\n".join(additional_lines)
        else:
            full_output = output

        print(full_output)  # Full text (may include next/prev)
        print(output)  # Short text (just main line)
        print(color)  # Color

    except Exception as e:
        # Unexpected error
        print(f"⏹ Error: {e}")
        print("⏹ Error")
        print("#808080")
    finally:
        if client:
            client.close()


if __name__ == "__main__":
    main()
